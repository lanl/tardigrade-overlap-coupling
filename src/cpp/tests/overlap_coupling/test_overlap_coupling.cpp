//!The test file for overlap_coupling.cpp

#include<iostream>
#include<vector>
#include<fstream>
#include<math.h>

#include "occonfiguration.h"
#define OVERLAP_LIBCOMPILE
#include "overlap_coupling.h"

bool fuzzy_equals(double a, double b, double tolr=1e-6, double tola=1e-6){
    /*!
    Compare two doubles to determine if they are equal.
    */

    double tol = fmin(tolr*fabs(a) + tola, tolr*fabs(b) + tola);
    return fabs(a-b)<tol;
}

bool fuzzy_equals(std::vector< double > a, std::vector< double > b, double tolr=1e-6, double tola=1e-6){
    /*!
    Compare two vectors to determine if they are equal
    */

    if (a.size() != b.size()){
        std::cout << "Error: vectors must have the same size.\n";
        assert(1==0);
    }

    for (unsigned int i=0; i<a.size(); i++){
        if (!fuzzy_equals(a[i], b[i], tolr, tola)){
            return false;
        }
    }
    return true;
}

bool fuzzy_equals(overlap::vecOfvec A, overlap::vecOfvec B, double tolr=1e-6, double tola=1e-6){
    /*!
    Compare two matrices to determine if they are equal
    */

    if (A.size() != B.size()){
        std::cout << "Error: matrices must have the same size.\n";
        assert(1==0);
    }

    for (unsigned int i=0; i<A.size(); i++){
        if (!fuzzy_equals(A[i], B[i], tolr, tola)){
            return false;
        }
    }
    return true;
}

//!From voro++ documentation
// This function returns a random double between 0 and 1
double rnd() {return double(rand())/RAND_MAX;}
//!End from voro++ documentation

template<typename T>
void print_vector(std::vector< T > vector){
    /*!
    Print the vector to the terminal
    */
    for (unsigned int i=0; i<vector.size(); i++){
        std::cout << vector[i] << " ";
    }
    std::cout << "\n";
    return;
}

template<typename T>
void print_matrix(std::vector< std::vector< T > > matrix){
    /*!
    Print the matrix to the terminal.
    */
    for (unsigned int i=0; i<matrix.size(); i++){
        print_vector(matrix[i]);
    }
}

//Define test values for the functions
void getTestScalarValues(std::map< unsigned int, double > &values){
    /*!
     * Get scalar values which can be used in the test functions
     * 
     * :param std::map< unsigned int, double > &values: The values.
     */

    values =  {
        { 510, +0.3431780 },
        { 365, +0.7290497 },
        { 382, +0.4385722 },
        { 322, +0.0596779 },
        { 988, +0.3980443 },
        {  98, +0.7379954 },
        { 742, +0.1824917 },
        {  17, +0.1754518 },
        { 595, +0.5315514 },
        { 106, +0.5318276 },
        { 123, +0.6344010 },
        { 569, +0.8494318 },
        { 214, +0.7244553 },
        { 737, +0.6110235 },
        {  96, +0.7224434 },
        { 113, +0.3229589 },
        { 638, +0.3617887 },
        {  47, +0.2282632 },
        {  73, +0.2937140 },
        { 544, +0.6309761 },
    };
}

void getTestStresses(std::map< unsigned int, std::vector< double > > &stresses){
    /*!
     * Get stress values which can be used in the test functions.
     * 
     * :param std::map< unsigned int, std::vector< double > > &stresses: The test stresses.
     */

    stresses = {
         { 510, { +0.1842099, +0.8516606, +1.8883200, +1.2056504, +0.8572141, +0.9273863} },
         { 365, { +1.0036734, +0.8296524, +1.9711196, +1.3493434, +0.3660738, +0.9412384} },
         { 382, { +1.0389702, +1.2061203, +0.8340444, +0.8491888, +0.4633925, +1.4392353} },
         { 322, { +1.3626015, +1.1718731, +0.1663900, +1.4672459, +1.1851114, +1.5447706} },
         { 988, { +1.5273657, +0.1914250, +0.0322584, +1.6087432, +0.8214719, +0.8161233} },
         {  98, { +1.1888638, +1.3910591, +0.7779011, +0.8731497, +0.8509299, +0.7098557} },
         { 742, { +1.8502650, +0.6095361, +0.7118297, +1.3935442, +1.0623564, +0.8852615} },
         {  17, { +1.5250956, +0.7977526, +1.3332491, +0.7539841, +1.0351578, +0.7443044} },
         { 595, { +0.2118170, +1.6930125, +0.6335758, +0.9380952, +1.1764331, +0.7924593} },
         { 106, { +0.7085294, +1.1047402, +1.9766908, +0.5812395, +1.3506457, +0.5097527} },
         { 123, { +1.8106832, +1.8038227, +1.6139374, +1.5479899, +0.5500315, +0.7276460} },
         { 569, { +0.7887401, +1.7317289, +0.4090857, +1.4118689, +0.2404348, +1.3317716} },
         { 214, { +0.9012730, +1.8551685, +1.4837243, +1.3225297, +0.5507387, +0.8446243} },
         { 737, { +0.0971581, +1.5619959, +0.2227843, +0.9517981, +1.1457131, +0.8746353} },
         {  96, { +1.3297449, +0.8764288, +1.1653422, +0.8500003, +1.2619533, +1.3281847} },
         { 113, { +1.6296874, +1.1481277, +1.6430082, +1.6110331, +1.0067255, +1.0877834} },
         { 638, { +1.8197433, +0.7987574, +0.4027990, +0.5465504, +0.6439985, +0.2670468} },
         {  47, { +1.6232887, +1.1031855, +1.4355151, +1.1380279, +1.3901137, +0.4754140} },
         {  73, { +0.7579717, +0.0643959, +1.0852719, +0.8665350, +0.5022327, +1.3042843} },
         { 544, { +0.1335489, +1.1475482, +0.0981943, +0.7638031, +1.6959204, +1.4227622} },
    };
}

void getTestWeights(std::vector< overlap::integrateMap > &weights){
    /*!
     * Get weights which can be used in the test functions
     * 
     * :param std::vector< overlap::integrateMap > &weights: The integration weights.
     */

    weights = {
        {
            {569, overlap::MicroPoint( 0.6012203,
                                      { +0.4033268, -0.6562957, -0.4131697 },
                                      { -2.4702858, -0.6714044, +0.1694299 },
                                      {  2,   3,   4 },
                                      {0.5934626, 0.7871275, 1.6761623, },
                                      {
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.6516426, +0.9538969, +0.4770002 },
                                       { +0.8788935, +0.7922078, +0.2653575 },
                                       { +0.7624383, +0.8227364, +0.3529924 },
                                      }
                                     )
            },
            {382, overlap::MicroPoint( 1.9484640,
                                      { +0.5257001, +0.5981389, -0.1212092 },
                                      { -2.1513254, +2.4899009, +0.6887548 },
                                      {  4,   0,   2 },
                                      {1.1929738, 0.0327850, 1.4423687, },
                                      {
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                      },
                                      {
                                       { +0.0077375, +0.0848223, +0.2254984 },
                                       { +0.8751245, +0.3635763, +0.5399599 },
                                       { +0.5681032, +0.2254634, +0.5721468 },
                                      }
                                     )
            },
            {638, overlap::MicroPoint( 1.3219036,
                                      { -0.6052638, -0.2441194, -0.1407332 },
                                      { +2.1617533, +0.4374687, +2.2412619 },
                                      {  2,   1,   0 },
                                      {1.8549100, 0.3967314, 0.1041823, },
                                      {
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                      },
                                      {
                                       { +0.4067789, +0.3723965, +0.8571531 },
                                       { +0.0266111, +0.9201492, +0.6809030 },
                                       { +0.9042260, +0.6075291, +0.8119533 },
                                      }
                                     )
            },
            {595, overlap::MicroPoint( 0.6710877,
                                      { -0.4513013, -0.3303773, +0.7643912 },
                                      { -0.6535441, -1.2889010, +2.1883418 },
                                      {  0,   3,   5 },
                                      {0.6726791, 0.6541998, 1.7645522, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                      },
                                      {
                                       { +0.8223038, +0.7096232, +0.9593452 },
                                       { +0.4225434, +0.2450330, +0.1173984 },
                                       { +0.3010534, +0.1452637, +0.0921861 },
                                      }
                                     )
            },
            {544, overlap::MicroPoint( 1.2058644,
                                      { -0.4074377, +0.1937110, -0.9259928 },
                                      { +0.8845293, -1.4224728, -1.1098820 },
                                      {  0,   2,   3 },
                                      {1.0859776, 1.3879694, 1.8242642, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                      },
                                      {
                                       { +0.5807132, +0.2326864, +0.7466976 },
                                       { +0.7777690, +0.2004013, +0.8205742 },
                                       { +0.4649349, +0.7797667, +0.2374782 },
                                      }
                                     )
            },
            {510, overlap::MicroPoint( 0.6651605,
                                      { +1.3610914, +0.4734452, +0.8186335 },
                                      { +0.9418717, -1.4784794, -0.1465563 },
                                      {  3,   1,   4 },
                                      {0.6935894, 1.8887311, 0.9823810, },
                                      {
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.2701763, +0.3604237, +0.2106526 },
                                       { +0.4212001, +0.2180354, +0.8457525 },
                                       { +0.4562706, +0.2798020, +0.9328916 },
                                      }
                                     )
            },
            { 47, overlap::MicroPoint( 0.6287027,
                                      { +1.2291440, -1.3697457, +0.6213452 },
                                      { -0.0805548, -0.2788947, -2.3183833 },
                                      {  5,   0,   1 },
                                      {0.7377497, 1.2239541, 0.4122631, },
                                      {
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                      },
                                      {
                                       { +0.1650664, +0.3618173, +0.8633534 },
                                       { +0.5094017, +0.2969015, +0.9502516 },
                                       { +0.8159661, +0.3229739, +0.9720982 },
                                      }
                                     )
            },
            {214, overlap::MicroPoint( 1.9747022,
                                      { -0.2740196, +0.4677693, -0.2830404 },
                                      { -1.2132595, -2.0867366, -1.1819483 },
                                      {  5,   3,   0 },
                                      {0.0349134, 0.9455188, 1.6882053, },
                                      {
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                      },
                                      {
                                       { +0.8870981, +0.3006310, +0.9387660 },
                                       { +0.5883242, +0.0987148, +0.0963425 },
                                       { +0.5656110, +0.7567387, +0.1391075 },
                                      }
                                     )
            },
            {365, overlap::MicroPoint( 0.7449484,
                                      { +1.4652974, +1.2084341, -0.4470778 },
                                      { -0.0578393, +0.5298717, -2.4643271 },
                                      {  0,   5,   1 },
                                      {1.8201213, 0.7901968, 0.9388145, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                      },
                                      {
                                       { +0.6096645, +0.8213163, +0.4811260 },
                                       { +0.2468874, +0.4023471, +0.2045267 },
                                       { +0.7706351, +0.1189544, +0.9844760 },
                                      }
                                     )
            },
            { 17, overlap::MicroPoint( 0.5131304,
                                      { -0.3118702, +0.4213626, +0.3148624 },
                                      { +2.0352526, +2.2920073, +0.2576903 },
                                      {  5,   3,   4 },
                                      {1.8301823, 1.0717035, 0.4108028, },
                                      {
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.5668986, +0.9569090, +0.2482819 },
                                       { +0.6140365, +0.5200761, +0.0546015 },
                                       { +0.5093249, +0.0022845, +0.1859040 },
                                      }
                                     )
            },
        },
        {
            { 73, overlap::MicroPoint( 1.5389156,
                                      { -0.4968030, -0.6534576, -0.3328540 },
                                      { +0.3467983, +0.3217321, -1.5760678 },
                                      {  0,   4,   1 },
                                      {1.6277680, 1.9721489, 1.5495559, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                      },
                                      {
                                       { +0.7812646, +0.8788719, +0.8628774 },
                                       { +0.4098105, +0.3039995, +0.9805664 },
                                       { +0.8408918, +0.7795716, +0.6755298 },
                                      }
                                     )
            },
            {595, overlap::MicroPoint( 1.5458689,
                                      { -0.5700370, +0.7341637, -1.0764155 },
                                      { +0.2941322, -1.3035787, +1.2943069 },
                                      {  1,   4,   0 },
                                      {0.8940182, 1.8254490, 1.5245881, },
                                      {
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                      },
                                      {
                                       { +0.3481879, +0.8984684, +0.8653109 },
                                       { +0.8522783, +0.9076021, +0.3751412 },
                                       { +0.2795041, +0.6903961, +0.0129746 },
                                      }
                                     )
            },
            {742, overlap::MicroPoint( 0.0618189,
                                      { -1.3429968, -1.1612007, +0.7420624 },
                                      { +1.9592358, +2.2827934, +2.2812661 },
                                      {  5,   3,   4 },
                                      {1.7238242, 1.1351483, 0.3516565, },
                                      {
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.5103764, +0.7569458, +0.1101052 },
                                       { +0.8170991, +0.1674816, +0.5340765 },
                                       { +0.3857435, +0.2486238, +0.6474325 },
                                      }
                                     )
            },
            {988, overlap::MicroPoint( 0.0747842,
                                      { +0.7801374, +0.0808219, +1.1273136 },
                                      { +0.1035916, -2.3248342, -1.7819952 },
                                      {  3,   4,   2 },
                                      {1.7328856, 1.7453278, 1.7912716, },
                                      {
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                      },
                                      {
                                       { +0.3686728, +0.8714321, +0.5907505 },
                                       { +0.7700631, +0.3352383, +0.1341989 },
                                       { +0.6290066, +0.2184186, +0.8067946 },
                                      }
                                     )
            },
            {322, overlap::MicroPoint( 0.9087123,
                                      { +1.0358142, -1.4329319, -1.3904810 },
                                      { -2.3058695, +1.2060998, +1.1640792 },
                                      {  4,   0,   5 },
                                      {0.8055743, 0.2436791, 1.0514231, },
                                      {
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                      },
                                      {
                                       { +0.4462484, +0.6633928, +0.5494131 },
                                       { +0.0275429, +0.0319180, +0.7013598 },
                                       { +0.7075811, +0.9599391, +0.8767047 },
                                      }
                                     )
            },
            {106, overlap::MicroPoint( 0.9361193,
                                      { +0.3777195, -0.1284548, -0.8311613 },
                                      { -0.6166150, -1.9805788, +0.8326356 },
                                      {  1,   3,   2 },
                                      {1.8395517, 0.3321966, 1.5089302, },
                                      {
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                      },
                                      {
                                       { +0.9785265, +0.9877837, +0.7878710 },
                                       { +0.4297222, +0.1244938, +0.2432808 },
                                       { +0.1221406, +0.8835153, +0.5545953 },
                                      }
                                     )
            },
            {365, overlap::MicroPoint( 1.1052361,
                                      { -0.3605897, -1.4116796, +0.5030173 },
                                      { -1.6954741, +0.0928265, +0.2646573 },
                                      {  0,   4,   1 },
                                      {0.6724598, 1.9917222, 1.3175352, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                      },
                                      {
                                       { +0.1960095, +0.0981840, +0.9431806 },
                                       { +0.9447778, +0.6213284, +0.0169915 },
                                       { +0.2255349, +0.8012768, +0.8754598 },
                                      }
                                     )
            },
            { 17, overlap::MicroPoint( 0.9079796,
                                      { -0.4034381, -0.6773250, -1.1490885 },
                                      { -1.9212773, +2.2630135, +1.5431306 },
                                      {  0,   1,   5 },
                                      {1.5293284, 1.6206297, 0.3266754, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                      },
                                      {
                                       { +0.9841283, +0.2278021, +0.5894154 },
                                       { +0.5876158, +0.9673619, +0.6576674 },
                                       { +0.5849043, +0.5187726, +0.7646575 },
                                      }
                                     )
            },
            {214, overlap::MicroPoint( 0.2121105,
                                      { -1.4937243, +1.3574666, -0.0040270 },
                                      { -0.8583231, -0.6597337, +1.5192166 },
                                      {  2,   1,   3 },
                                      {1.6881549, 0.1524081, 0.9622567, },
                                      {
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                      },
                                      {
                                       { +0.4668497, +0.2643280, +0.9436147 },
                                       { +0.9050285, +0.4435963, +0.0971596 },
                                       { +0.2067831, +0.2714918, +0.4842198 },
                                      }
                                     )
            },
            { 96, overlap::MicroPoint( 0.6767542,
                                      { +0.8224082, -0.0719202, +1.1111115 },
                                      { +2.4789088, -1.4008202, +0.5583569 },
                                      {  4,   5,   0 },
                                      {1.4540855, 0.0300323, 1.7582849, },
                                      {
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                      },
                                      {
                                       { +0.0639385, +0.7333954, +0.9946104 },
                                       { +0.5011898, +0.2093340, +0.5946436 },
                                       { +0.6241500, +0.6680727, +0.1726117 },
                                      }
                                     )
            },
        },
        {
            {214, overlap::MicroPoint( 1.7974254,
                                      { +0.3629741, -1.3692939, +0.5521232 },
                                      { -1.5195798, -2.3632961, +0.2547664 },
                                      {  0,   1,   4 },
                                      {0.7479560, 0.5224543, 0.6716775, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.8016648, +0.9644626, +0.0546013 },
                                       { +0.4597043, +0.2676096, +0.5391694 },
                                       { +0.7525107, +0.9245414, +0.3197199 },
                                      }
                                     )
            },
            {737, overlap::MicroPoint( 1.7589508,
                                      { -0.9886156, +0.1783643, -0.3159547 },
                                      { +1.7156760, +2.3201456, -2.2886545 },
                                      {  4,   2,   1 },
                                      {1.0741596, 1.7955055, 1.8941350, },
                                      {
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                      },
                                      {
                                       { +0.9153545, +0.7545183, +0.2463210 },
                                       { +0.3852714, +0.2800000, +0.6576602 },
                                       { +0.3242216, +0.7543916, +0.1135091 },
                                      }
                                     )
            },
            { 73, overlap::MicroPoint( 1.5507295,
                                      { +0.2577059, +1.0061661, -0.2073730 },
                                      { +0.6248223, +0.2720607, +2.3783563 },
                                      {  0,   1,   2 },
                                      {1.5823947, 0.0762484, 1.0566233, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                      },
                                      {
                                       { +0.0280954, +0.4422135, +0.9940934 },
                                       { +0.3393571, +0.8242797, +0.1533247 },
                                       { +0.9666495, +0.5681093, +0.3203648 },
                                      }
                                     )
            },
            {382, overlap::MicroPoint( 0.3345503,
                                      { -1.1981275, +0.8915733, -1.3269356 },
                                      { -0.9643763, +0.3213578, +1.2864246 },
                                      {  4,   5,   3 },
                                      {0.3173583, 0.8398463, 0.4924858, },
                                      {
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                      },
                                      {
                                       { +0.2053498, +0.6848259, +0.4861117 },
                                       { +0.3249096, +0.1002145, +0.5447634 },
                                       { +0.3470252, +0.3910958, +0.3105087 },
                                      }
                                     )
            },
            {106, overlap::MicroPoint( 0.7743904,
                                      { +0.1675788, -1.4575686, +1.0429410 },
                                      { +2.1095993, +0.2526485, -1.1598944 },
                                      {  3,   1,   4 },
                                      {1.3799051, 0.8686181, 0.3983163, },
                                      {
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.9665794, +0.0636909, +0.4851494 },
                                       { +0.2207307, +0.2939741, +0.8285273 },
                                       { +0.3672656, +0.0833483, +0.1963090 },
                                      }
                                     )
            },
            {365, overlap::MicroPoint( 1.7207468,
                                      { +1.4310866, -0.6960535, +0.5262270 },
                                      { -2.0940050, +1.1173280, -0.4178169 },
                                      {  5,   3,   4 },
                                      {1.0064949, 0.6977858, 1.2940392, },
                                      {
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                      },
                                      {
                                       { +0.2497462, +0.2297636, +0.1963464 },
                                       { +0.9598996, +0.4929137, +0.7516150 },
                                       { +0.4739919, +0.5875402, +0.5841390 },
                                      }
                                     )
            },
            {322, overlap::MicroPoint( 1.9597726,
                                      { +0.5052994, -0.7806916, -1.4544070 },
                                      { -1.4065893, -0.2224018, -0.5328983 },
                                      {  4,   1,   3 },
                                      {0.7745992, 1.0739962, 1.7135848, },
                                      {
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                      },
                                      {
                                       { +0.8652405, +0.5558860, +0.6072792 },
                                       { +0.8023366, +0.2839966, +0.4875621 },
                                       { +0.3998851, +0.2962658, +0.6102295 },
                                      }
                                     )
            },
            { 47, overlap::MicroPoint( 0.3554548,
                                      { -0.4782107, +0.8871771, +0.9518001 },
                                      { +0.7595405, +1.9502218, -2.2716757 },
                                      {  0,   4,   3 },
                                      {1.2397022, 0.6585583, 0.6145093, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.4073162, +0.6445803, +0.6470006 },
                                       { -0.5338055, -0.1410125, +0.8337669 },
                                      },
                                      {
                                       { +0.7511212, +0.7586246, +0.7187658 },
                                       { +0.1011820, +0.5161660, +0.5577987 },
                                       { +0.7448045, +0.9031777, +0.3690389 },
                                      }
                                     )
            },
            {595, overlap::MicroPoint( 0.8573269,
                                      { +0.6983025, +0.4879093, +0.1736097 },
                                      { -0.7493018, -1.5232383, -1.5809631 },
                                      {  1,   5,   0 },
                                      {1.3792580, 0.3834348, 1.9086683, },
                                      {
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                       { -0.9960542, -0.0885822, +0.0054014 },
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                      },
                                      {
                                       { +0.7972177, +0.8576749, +0.1245614 },
                                       { +0.0950604, +0.6744341, +0.6084567 },
                                       { +0.3857295, +0.1592167, +0.4938799 },
                                      }
                                     )
            },
            { 17, overlap::MicroPoint( 0.3579622,
                                      { -1.1324990, +1.1119856, +0.0584941 },
                                      { -0.9045072, +1.0970332, +2.3215634 },
                                      {  0,   2,   1 },
                                      {0.0432937, 1.0702828, 0.8459465, },
                                      {
                                       { +0.9674501, +0.0619480, -0.2453626 },
                                       { -0.6333563, -0.3554619, +0.6873912 },
                                       { +0.9541165, -0.2927724, -0.0628173 },
                                      },
                                      {
                                       { +0.1575336, +0.1190697, +0.4493519 },
                                       { +0.0399131, +0.9865799, +0.3781209 },
                                       { +0.3821092, +0.0511263, +0.4266723 },
                                      }
                                     )
            },
        },
    };

    return;
}

void test_map_vector_to_quickhull(std::ofstream &results){
    /*!
    Test mapping a std::vector to a 3D-quickhull vertex.
    */

    std::vector< double > a(3,0);
    a[1] = 1;
    a[2] = 2;

    overlap::OverlapCoupling oc;
    vertex_t result = oc.map_vector_to_quickhull(a);

    if (!((result.x == a[0]) && (result.y == a[1]) && (result.z == a[2]))){
        results << "test_map_vector_to_quickhull & False\n";
    }
    else{
        results << "test_map_vector_to_quickhull & True\n";
    }
}

void test_map_quickhull_to_vector(std::ofstream &results){
    /*!
    Test mapping a 3D-quickhull vertex to a std::vector
    */

    vertex_t v;
    v.x = 1.2;
    v.y = 3.7;
    v.z = -1.2;

    overlap::OverlapCoupling oc;
    std::vector< double > result = oc.map_quickhull_to_vector(v);

    if (!(vectorTools::fuzzyEquals(result[0],v.x) && (vectorTools::fuzzyEquals(result[1],v.y)) && (vectorTools::fuzzyEquals(result[2], v.z)))){
        results << "test_map_quickhull_to_vector & False\n";
        return;
    }

    results << "test_map_quickhull_to_vector & True\n";
    return;
}

void test_mapVectorsToQuickhull(std::ofstream &results){
    /*!
    Test mapping a collection of std::vectors to a 3D-quickhull vertex.
    */

    std::vector< double > a(3,0), b(3,-1);
    a[1] = 1;
    a[2] = 2;
    b[1] = .32;
    b[2] = 7.8;

//    overlap::vecOfvec in;
//    in.push_back(a);
//    in.push_back(b);

    std::map< unsigned int, std::vector< double > > in;
    std::vector< unsigned int > idNumbers = {10, 2};
    in.emplace(idNumbers[0], a);
    in.emplace(idNumbers[1], b);

    overlap::OverlapCoupling oc;
    std::vector< vertex_t > result;
    oc.mapVectorsToQuickhull(in, result);

    unsigned int i=0;
    for (auto vector=in.begin(); vector!=in.end(); vector++, i++){//unsigned int i=0; i<in.size(); i++){
//        if (!vectorTools::fuzzyEquals(in[i][0], result[i].x) || !vectorTools::fuzzyEquals(in[i][1], result[i].y) || !vectorTools::fuzzyEquals(in[i][2], result[i].z)){
//            print_vector(in[i]);
//            std::cout << result[i].x << " " << result[i].y << " " << result[i].z << "\n";
        if ( (!vectorTools::fuzzyEquals(vector->second[0], result[i].x)) || 
             (!vectorTools::fuzzyEquals(vector->second[1], result[i].y)) ||
             (!vectorTools::fuzzyEquals(vector->second[2], result[i].z)) ){

            results << "test_mapVectorsToQuickhull & False\n";
            return;
        }
    }

    results << "test_mapVectorsToQuickhull & True\n";
    return;
}

void test_map_quickhull_to_vectors(std::ofstream &results){
    /*!
    Test mapping a collection of 3D-quickhull vertices to a vector of std::vectors
    */

    vertex_t v1, v2;
    v1.x = 1.;
    v1.y = 2.;
    v1.z = 3.;

    v2.x = .27;
    v2.y = 1.23;
    v2.z = -2.1;

    std::vector< vertex_t > in;
    in.push_back(v1);
    in.push_back(v2);

    overlap::OverlapCoupling oc;
    overlap::vecOfvec result;
    oc.map_quickhull_to_vectors(in, result);

    for (unsigned int i=0; i<in.size(); i++){
        if (!(vectorTools::fuzzyEquals(result[i][0], in[i].x) && vectorTools::fuzzyEquals(result[i][1], in[i].y) && vectorTools::fuzzyEquals(result[i][2], in[i].z))){
            results << "test_map_quickhull_to_vectors & False\n";
            return;
        }
    }

    results << "test_map_quickhull_to_vectors & True\n";
    return;
}

void test_dot(std::ofstream &results){
    /*!
    Test the computation of the dot product of two vectors.
    */

    std::vector< double > a(3,0), b(3,-1);
    a[1] = 1;
    a[2] = 2;
    b[1] = 0.32;
    b[2] = 7.8;

    double result = overlap::dot(a, b);
    
    double answer = a[0]*b[0] + a[1]*b[1] + a[2]*b[2];

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_dot & False\n";
        return;
    }
    results << "test_dot & True\n";
    return;
    
}

void test_cross(std::ofstream &results){
    /*!
    Test the computation of the cross product of two vectors.
    */

    std::vector< double > a(3,0), b(3,-1);
    a[1] = 1;
    a[2] = 2;
    b[1] = 0.32;
    b[2] = 7.8;

    std::vector< double > result = vectorTools::cross(a, b);

    if ((!vectorTools::fuzzyEquals(overlap::dot(result, a), 0.)) || (!vectorTools::fuzzyEquals(overlap::dot(result, b), 0.))){
        results << "test_cross & False\n";
        return;
    }
    results << "test_cross & True\n";
    return;
}

void test_fuzzy_equals(std::ofstream &results){
    /*!
    Test the comparison of two values using the fuzzy (tolerant) comparison.
    */

    double a = 1;
    double b = 1;

    if (!vectorTools::fuzzyEquals(a, b)){
        results << "test_fuzzy_equals (test 1) & False\n";
        return;
    }

    a += 1e-3;
    if (vectorTools::fuzzyEquals(a, b)){
        results << "test_fuzzy_equals (test 2) & False\n";
        return;
    }

    a = -1;
    b = -1;

    if (!vectorTools::fuzzyEquals(a, b)){
        results << "test_fuzzy_equals (test 3) & False\n";
        return;
    }

    results << "test_fuzzy_equals & True\n";
    return;
}

void test_compare_vector_directions(std::ofstream &results){
    /*!
    Test the comparison of two vector directions for equality.
    */
//    std::cout << "Testing the comparision of vector directions...\n";

    std::vector< double > a(3, 1), b(3, 3);
    
    if (!overlap::compare_vector_directions(a, b)){
        results << "test_compare_vector_directions (test 1) & False\n";
        return;
    }

    a[0] += 1;
    if (overlap::compare_vector_directions(a, b)){
        results << "test_compare_vector_directions (test 2) & False\n";
        return;
    }

    a[0] = 1;
    a[1] = 2;
    a[2] = 3;
    b[0] = -1;
    b[1] = -2;
    b[2] = -3;

    if (overlap::compare_vector_directions(a, b)){
        results << "test_compare_vector_directions (test 3) & False\n";
        assert(1==0);
        return;
    }

    results << "test_compare_vector_directions & True\n";
    return;
}

void test_compute_element_bounds(std::ofstream &results){
    /*!
    Test the computation of the element bounds (also tests compute_unique_planes)
    */
//    std::cout << "Testing the computation of the element bounds...\n";
    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc(data.local_nodes, data.local_gpts);
    const overlap::planeMap *element_planes = oc.get_element_planes();
    const overlap::vecOfvec *element_bounds = oc.get_element_bounds();

    if (element_planes->size()!=6){
        results << "test_compute_element_bounds (test 1)& False\n";
        return;
    }

    //!Assumes the underlying element is a hex
    overlap::planeMap::const_iterator it;
    for (it=element_planes->begin(); it!=element_planes->end(); it++){
        for (unsigned int i=0; i<it->first.size(); i++){
//            print_vector(it->first);
//            print_vector(it->second);
            if (vectorTools::fuzzyEquals(fabs(it->first[i]), 1.)){
                if (!vectorTools::fuzzyEquals(it->first[i], it->second[i])){
                    results << "test_compute_element_bounds (test 2) & False\n";
                    return;
                }
            }
        }
    }

    //!Check the bounds (assuming it is a hex)
    std::vector< double > answer(2, 1);
    answer[0] = -1;
    for (unsigned int i=0; i<3; i++){
        if (!vectorTools::fuzzyEquals(answer, (*element_bounds)[i])){
            results << "test_compute_element_bounds(test 3) & False\n";
            return;
        }
    }

    results << "test_compute_element_bounds & True\n";
    return;
}

void test_compute_node_bounds(std::ofstream &results){
    /*!
    Test the computation of the node bounds.
    */
//    std::cout << "Testing the computation of the node bounds...\n";

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc = overlap::OverlapCoupling(data.local_nodes, data.local_gpts);
    overlap::planeMap dns_planes;
    std::vector< vertex_t > vertices;
    oc.mapVectorsToQuickhull(data.coordinates, vertices);

    overlap::vecOfvec bounds;
    bounds.resize(3);
    oc.compute_node_bounds(data.coordinates, dns_planes, bounds[0], bounds[1], bounds[2], 1e-9, 1e-9);

    if (dns_planes.size() != 6){
        results << "test_compute_node_bounds (test 1) & False\n";
        return;
    }

    overlap::vecOfvec answer(3);
    for (unsigned int i=0; i<answer.size(); i++){
        answer[i] = std::vector< double >(2,1);
    }
    answer[0][0] = 0;
    answer[1][0] = answer[2][0] = -1;

    for (unsigned int i=0; i<3; i++){
        if (!(vectorTools::fuzzyEquals(answer[i], bounds[i]))){
            results << "test_compute_node_bounds (test 2) & False\n";
            return;
        }
    }

    results << "test_compute_node_bounds & True\n";
    return;
}

void test_extract_mesh_info(std::ofstream &results){
    /*!
    Test the extraction of the mesh information
    */
//    std::cout << "Testing the extraction of the mesh information...\n";

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc;
    std::vector< vertex_t > vertices;

    std::map< unsigned int, std::vector< double > > localNodesMap;
    for (unsigned int i=0; i<data.local_nodes.size(); i++){
        localNodesMap.emplace(i, data.local_nodes[i]);
    }

    oc.mapVectorsToQuickhull(localNodesMap, vertices);
    #if CONVEXLIB == QUICKHULL
        mesh_t mesh = qh_quickhull3d(&vertices[0], vertices.size());
    #elif CONVEXLIB == CONVHULL_3D
        mesh_t mesh;
        int *faceIndices = NULL;
        int nFaces;
        convhull_3d_build(&vertices[0], vertices.size(), &faceIndices, &nFaces);
        mesh.first.assign(faceIndices, faceIndices + nFaces);
        mesh.second = vertices;
    #elif CONVEXLIB == AKUUKKA
        quickhull::QuickHull<FloatType> qh;
        mesh_t mesh = qh.getConvexHull(vertices, false, false);
    #endif

    overlap::vecOfvec normals;
    overlap::vecOfvec points;

    oc.extract_mesh_info(mesh, normals, points);

    #if CONVEXLIB == QUICKHULL

        if (mesh.nnormals != normals.size()){
            results << "test_extract_mesh_info (test 1) & False\n";
            return;
        }
        if (mesh.nnormals != points.size()){
            results << "test_extract_mesh_info (test 2) & False\n";
            return;
        }

    #elif CONVEXLIB == CONVHULL_3D
        if (mesh.first.size()/3 != normals.size()){
            results << "test_extract_mesh_info (test 1) & False\n";
            return;
        }
        if (mesh.first.size()/3 != points.size()){
            results << "test_extract_mesh_info (test 2) & False\n";
            return;
        }
    #elif CONVEXLIB == AKUUKKA
        auto indexBuffer = mesh.getIndexBuffer();

        if (indexBuffer.size()/3 != normals.size()){
            results << "test_extract_mesh_info (test 1) & False\n";
            return;
        }
        if (indexBuffer.size()/3 != points.size()){
            results << "test_extract_mesh_info (test 2) & False\n";
            return;
        }
    #endif

    unsigned int index = 0;
    vertex_t temp_vertex;
    for (unsigned int i=0; i<normals.size(); i++){
        #if CONVEXLIB == QUICKHULL
            if (!(vectorTools::fuzzyEquals(normals[i][0], mesh.normals[i].x) && vectorTools::fuzzyEquals(normals[i][1], mesh.normals[i].y) && vectorTools::fuzzyEquals(normals[i][2], mesh.normals[i].z))){
                results << "test_extract_mesh_info (test 3) & False\n";
                return;
            }
            temp_vertex = mesh.vertices[mesh.indices[index]];

            if (!(vectorTools::fuzzyEquals(points[i][0], temp_vertex.x) && vectorTools::fuzzyEquals(points[i][1], temp_vertex.y) && vectorTools::fuzzyEquals(points[i][2], temp_vertex.z))){
                results << "test_extract_mesh_info (test 4) & False\n";
                return;
            }
//        #elif CONVEXLIB == CONVHULL_3D
//            if (!(vectorTools::fuzzyEquals(normals[i][0], mesh.normals[i].x) && vectorTools::fuzzyEquals(normals[i][1], mesh.normals[i].y) && vectorTools::fuzzyEquals(normals[i][2], mesh.normals[i].z))){
//                results << "test_extract_mesh_info (test 3) & False\n";
//                return;
//            }
//            temp_vertex = mesh.vertices[mesh.indices[index]];
//
//            if (!(vectorTools::fuzzyEquals(points[i][0], temp_vertex.x) && vectorTools::fuzzyEquals(points[i][1], temp_vertex.y) && vectorTools::fuzzyEquals(points[i][2], temp_vertex.z))){
//                results << "test_extract_mesh_info (test 4) & False\n";
//                return;
//            }

        #endif


        index += 3;

    }

    results << "test_extract_mesh_info & True\n";
    return;
}

void test_normal_from_vertices(std::ofstream &results){
    /*!
    Test the computation of a normal from a set of three vertices that 
    define a plane.
    */
//    std::cout << "Testing normal from vertices...\n";
    vertex_t v1, v2, v3;
    v1.x = 1;
    v1.y = 0;
    v1.z = 0;

    v2.x = 0;
    v2.y = 1;
    v2.z = 0;

    v3.x = 0;
    v3.y = 0;
    v3.z = 1;

    std::vector< double > result;
    overlap::normal_from_vertices(v1, v2, v3, result);

    std::vector< double > answer(3, 1./sqrt(3));

    if (!vectorTools::fuzzyEquals(answer, result)){
        results << "test_normal_from_vertices & False\n";
        return;
    }

    results << "test_normal_from_vertices & True\n";
    return;
}

void test_compute_dns_bounds(std::ofstream &results){
    /*!
    Test the computation of the bounding planes for the DNS point positions.
    */
//    std::cout << "Testing the computation of the dns bounds...\n";

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc = overlap::OverlapCoupling(data.local_nodes, data.local_gpts);
    oc.compute_dns_bounds(data.coordinates, true);
    const overlap::planeMap *dns_planes = oc.get_dns_planes();
    const overlap::vecOfvec *dns_bounds = oc.get_dns_bounds();

    //!Compare bounds to expected values
    overlap::vecOfvec answer(3);
    for (unsigned int i=0; i<answer.size(); i++){
        answer[i] = std::vector< double >(2,1);
    }

    answer[0][0] = 0;
    answer[1][0] = answer[2][0] = -1;

    for (unsigned int i=0; i<answer.size(); i++){
        if (!vectorTools::fuzzyEquals(answer[i], dns_bounds->operator[](i))){
            results << "test_compute_dns_bounds (test 1) & False\n";
            return;
        }
    }
    //!Assumes the underlying dns has a hexahedral domain
    overlap::planeMap::const_iterator it;
    for (it=dns_planes->begin(); it!=dns_planes->end(); it++){
        for (unsigned int i=0; i<it->first.size(); i++){
            if (vectorTools::fuzzyEquals(fabs(it->first[i]), 1.)){
                if (vectorTools::fuzzyEquals(it->first[i], 1.) && !vectorTools::fuzzyEquals(it->second[i], (*dns_bounds)[i][1])){
                    results << "test_compute_dns_bounds (test 2) & False\n";
                    return;
                }
                else if (vectorTools::fuzzyEquals(it->first[i], -1.) && !vectorTools::fuzzyEquals(it->second[i], (*dns_bounds)[i][0])){
                    results << "test_compute_dns_bounds (test 2) & False\n";
                    return;
                }
            }
        }
    }

    results << "test_compute_dns_bounds & True\n";
    return;
}

void test_construct_container(std::ofstream &results){
    /*!
    Tests the construction of a voro++ container class object. Also tests add_planes_to_container,
    evaluate_container_information, find_face_centroid, and map_planes_to_voro.
    */

    //Set the number of particles
    const int particles=64;

    const double x_min=-2, x_max=2;
    const double y_min=-2, y_max=2;
    const double z_min=-2, z_max=2;

    //Set the bounds
    overlap::vecOfvec bounds;
    bounds.resize(3);
    for (unsigned int i=0; i<bounds.size(); i++){
        bounds[i].resize(2);
        bounds[i][0] = -2;
        bounds[i][1] =  2;
    }

    //Build the bounding planes (tetrahedron)
    overlap::planeMap planes;
    planes.insert(std::pair< std::vector< double >, std::vector< double > >({ 1, 1, 1}, { 1, 0, 0}));
    planes.insert(std::pair< std::vector< double >, std::vector< double > >({-1,-1, 1}, {-1, 0, 0}));
    planes.insert(std::pair< std::vector< double >, std::vector< double > >({ 1,-1,-1}, { 0, 0,-1}));
    planes.insert(std::pair< std::vector< double >, std::vector< double > >({-1, 1,-1}, { 0, 1, 0}));

    //Construct voro++ planes from the definitions
    std::vector< voro::wall_plane > vplanes;
    overlap::map_planes_to_voro(planes, vplanes);
//    vplanes.reserve(planes.size());
//    double distance;
//    overlap::planeMap::iterator it;
//    int j=1;
//    for (it=planes.begin(); it!=planes.end(); it++){
//        distance = sqrt(overlap::dot(it->first, it->second));
//        vplanes.push_back(voro::wall_plane(it->first[0], it->first[1], it->first[2], distance, -j));
//        j++;
//    }

    //Define the point coordinates
    std::map< unsigned int, std::vector< double > > point_coords;
    std::vector< double > coord(3);

    double x, y, z;
    for (unsigned int i=0; i<particles; i++){
        x = x_min + rnd()*(x_max - x_min);
        y = y_min + rnd()*(y_max - y_min);
        z = z_min + rnd()*(z_max - z_min);

        coord = {x, y, z};
        point_coords.emplace(i, coord);
    }

    //Construct the container
    voro::container* container = overlap::construct_container(point_coords, bounds, vplanes);
    overlap::integrateMap points;
    std::map< unsigned int, FloatType > boundary_node_volumes;
    overlap::integrateMap::iterator itiM;
    std::map< int, std::pair< std::vector< FloatType >, std::vector< FloatType > > > bounding_faces;
    int i = 0;
    for (auto f = planes.begin(); f != planes.end(); f++, i++){
        bounding_faces.emplace(i, std::pair< std::vector< FloatType >, std::vector< FloatType > >(f->first, f->second));
    }
    overlap::evaluate_container_information(point_coords, bounding_faces, container, points, boundary_node_volumes);
    double result_d = 0;
    for (itiM=points.begin(); itiM!=points.end(); itiM++){
        result_d += itiM->second.volume;
    }
    double answer_d = 8./3;

    //Check that the volume is what was expected    
    if (!vectorTools::fuzzyEquals(result_d, answer_d)){
        results << "test_construct_container (test 1) & False\n";
        delete(container);
        return;
    }

    //Check that the surface areas are what was expected
    std::vector< double > sub_surface_areas(4, 0);
    for (itiM=points.begin(); itiM!=points.end(); itiM++){
        for (unsigned int j=0; j<itiM->second.normals.size(); j++){
            sub_surface_areas[itiM->second.planes[j]] += itiM->second.area(j);
        }
    }

    answer_d = sqrt(12);
    std::vector< double >::iterator vdit = sub_surface_areas.begin();
    while (vdit != sub_surface_areas.end()){
        if (!vectorTools::fuzzyEquals(*vdit, answer_d)){
            results << "test_construct_container (test 2) & False\n";
            delete(container);
            return;
        }
        vdit++;
    }

    //Check that the normals for each plane are consistent with expectations and that the centroids are on the plane
    overlap::planeMap::iterator it;
    std::vector< double > normal(3);
    for (itiM=points.begin(); itiM!=points.end(); itiM++){
        for (unsigned int i=0; i<itiM->second.planes.size(); i++){
            it = planes.begin();
            for (int j=0; j<itiM->second.planes[i]; j++){it++;}
            normal = it->first;
            for (unsigned int j=0; j<normal.size(); j++){normal[j] /= sqrt(overlap::dot(it->first, it->first));}
            std::vector< double > it_normal = itiM->second.normal(i);
            
            if (!vectorTools::fuzzyEquals(normal, it_normal)){
                results << "test_construct_container (test 3) & False\n";
                delete(container);
                return;
            }
            if (!vectorTools::fuzzyEquals(overlap::dot(normal, it->second), overlap::dot(normal, itiM->second.face_centroids[i]))){
                results << "test_construct_container (test 4) & False\n";
                delete(container);
                return;
            }
        }
    }

    results << "test_construct_container & True\n";
    delete(container);
    return;
}

void test_construct_gauss_domains(std::ofstream &results){
    /*!
    Test the construction of the gauss domains.
    */

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc = overlap::OverlapCoupling(data.local_nodes, data.local_gpts);
    const std::vector< overlap::MicroPoint > *gauss_domains = oc.get_gauss_domains();
    std::vector< double > pos(3,0);

    //Macro-element assumed to be a fully integrated linear hex
    for (unsigned int i=0; i<gauss_domains->size(); i++){
    
        //See if the volume is 1 as expected    
        if (!vectorTools::fuzzyEquals((*gauss_domains)[i].volume, 1.)){
            results << "test_construct_gauss_domains (test 1) & False\n";
            return;
        }

        //Make sure that the centroids are located where they are expected to be
        for (unsigned int j=0; j<(*gauss_domains)[i].coordinates.size(); j++){
            if (!vectorTools::fuzzyEquals(fabs((*gauss_domains)[i].coordinates[j]), 0.5)){
                results << "test_construct_gauss_domains (test 2) & False\n";
                return;
            }

            if (!vectorTools::fuzzyEquals((*gauss_domains)[i].coordinates[j]/fabs((*gauss_domains)[i].coordinates[j]),
                              data.local_gpts[i][j]/fabs(data.local_gpts[i][j]))){
                results << "test_construct_gauss_domains (test 2) & False\n";
                return;
            }
        }

        //Make sure the surface areas are all 1
        for (unsigned int j=0; j<(*gauss_domains)[i].normals.size(); j++){
            if (!vectorTools::fuzzyEquals(1., (*gauss_domains)[i].area(j))){
                results << "test_construct_gauss_domains (test 3) & False\n";
                return;
            }
        }

        //Make sure the centroid is contained within the surfaces
        for (unsigned int j=0; j<(*gauss_domains)[i].normals.size(); j++){
            pos[0] = (*gauss_domains)[i].coordinates[0] - (*gauss_domains)[i].face_centroids[j][0];
            pos[1] = (*gauss_domains)[i].coordinates[1] - (*gauss_domains)[i].face_centroids[j][1];
            pos[2] = (*gauss_domains)[i].coordinates[2] - (*gauss_domains)[i].face_centroids[j][2];

            if (overlap::dot((*gauss_domains)[i].normal(j), pos)>0){
                results << "test_constructed_gauss_domains (test 4) & False\n";
                return;
            }
        }

    
    }

    results << "test_construct_gauss_domains & True\n";
    return;
}

void test_compute_weights(std::ofstream &results){
    /*!
    Test to make sure that the computation of weights and other required quantities is performed correctly.

    Also tests OverlapCoupling::map_domain_to_voro.
    */

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc = overlap::OverlapCoupling(data.local_nodes, data.local_gpts);
    std::vector< overlap::integrateMap > points;
    oc.compute_weights(data.coordinates, points);
    const std::vector< overlap::MicroPoint >* gauss_domains = oc.get_gauss_domains();

    overlap::integrateMap::iterator it;
    double total_volume;
    for (unsigned int gp = 0; gp<points.size(); gp++){
        total_volume = 0;
        for (it=points[gp].begin(); it!=points[gp].end(); it++){
            total_volume += it->second.volume;
        }

        //Make sure that the gauss domains are centered at the correct points
        if (!vectorTools::fuzzyEquals(fabs((*gauss_domains)[gp].coordinates[0]), 0.5)){
            results << "test_compute_weights (test 1) & False\n";
            return;
        }

        //Make sure that the gauss points have the expected overlapped volume
        if (((*gauss_domains)[gp].coordinates[0]<0) && (!vectorTools::fuzzyEquals(total_volume, 0.))){
            results << "test_compute_weights (test 2) & False\n";
            return;
        }
        else if (((*gauss_domains)[gp].coordinates[0]>0) && (!vectorTools::fuzzyEquals(total_volume, 1.))){
            results << "test_compute_weights (test 2) & False\n";
            return;
        }
    }

    results << "test_compute_weights & True\n";
    return;
}

void test_apply_nansons_relation(std::ofstream &results){
    /*!
    Test to make sure that the implementation of Nanson's relation is computed correctly.
    */

    overlap::vecOfvec Qx, Qy, Qz, Q;
    overlap::vecOfvec I;
    overlap::vecOfvec U;

    double theta_x = 30*(3.14159/180);
    double theta_y = 13*(3.14159/180);
    double theta_z = 68*(3.14159/180);

    //Set the size of the matrices
    Qx.resize(3); Qy.resize(3); Qz.resize(3);
    Q.resize(3);
    I.resize(3);
    U.resize(3);
    std::vector< double > zeros(3,0);
    for (unsigned int i=0; i<3; i++){
        Qx[i] = zeros; Qy[i]=zeros; Qz[i] = zeros;
        Q[i] = zeros;
        I[i] = zeros;
        U[i] = zeros;
    }
    
    //Set the terms of the identity matrix
    I[0][0] = I[1][1] = I[2][2] = 1.;

    //Set the terms of the rotation matrices
    //Qx
    Qx[0][0] = 1;
    Qx[1][1] = cos(theta_x); Qx[1][2] = -sin(theta_x);
    Qx[2][1] = sin(theta_x); Qx[2][2] =  cos(theta_x);
    //Qy
    Qy[0][0] = cos(theta_y); Qy[0][2] = sin(theta_y);
    Qy[1][1] = 1;
    Qy[2][0] = -sin(theta_y); Qy[2][2] = cos(theta_y);
    //Qz
    Qz[0][0] = cos(theta_z); Qz[0][1] = -sin(theta_z);
    Qz[1][0] = sin(theta_z); Qz[1][1] =  cos(theta_z);
    Qz[2][2] = 1;

    for (unsigned int i=0; i<3; i++){
        for (unsigned int j=0; j<3; j++){
            double tmp = 0;
            for (unsigned int k=0; k<3; k++){
                for (unsigned int l=0; l<3; l++){
                    tmp += Qz[i][k]*Qy[k][l]*Qx[l][j];
                }
            }
            Q[i][j] = tmp;
        }
    }

    //Test to make sure Q is orthogonal
    overlap::vecOfvec Qcheck(3);
    for (unsigned int i=0; i<3; i++){Qcheck[i] = zeros;}
    for (unsigned int i=0; i<3; i++){
        for (unsigned int j=0; j<3; j++){
            double tmp = 0;
            for (unsigned int k=0; k<3; k++){
                tmp += Q[k][i]*Q[k][j];
            }
            Qcheck[i][j] = tmp;
        }
    }

//    std::cout << "Q:\n";
//    print_matrix(Q);
//    std::cout << "Qcheck:\n";
//    print_matrix(Qcheck);
//    std::cout << "det Q: " << Q[0][0]*(Q[1][1]*Q[2][2] - Q[1][2]*Q[2][1]) - Q[0][1]*(Q[1][0]*Q[2][2] - Q[2][0]*Q[1][2]) + Q[0][2]*(Q[1][0]*Q[2][1] - Q[2][0]*Q[1][1]) << "\n";

    if (!vectorTools::fuzzyEquals(Qcheck, I)){
        results << "test_apply_nansons_relation (Q not orthogonal!) & False\n";
        return;
    }

    //Make sure that a vector transformed by a pure rotation has the same area
    std::vector< double > dA = {.812, -.352, 1.45};
    double A = sqrt(overlap::dot(dA, dA));
    std::vector< double > N(dA.size(), 0);
    for (unsigned int i=0; i<N.size(); i++){N[i] = dA[i]/A;}
    std::vector< double > result1;

    overlap::vecOfvec Qinv(3);
    for (unsigned int i=0; i<3; i++){
        Qinv[i] = zeros;
        for (unsigned int j=0; j<3; j++){
            Qinv[i][j] = Q[j][i];
        }
    }

    overlap::apply_nansons_relation(N, 1.*A, Qinv, result1);
    double a1 = sqrt(overlap::dot(result1, result1));

    if (!vectorTools::fuzzyEquals(a1, A)){
        results << "test_apply_nansons_relation (test 1) & False\n";
        return;
    }

    //Check that a transformation which induces a deformation is computed correctly
    U[0][0] = .5;
    U[1][1] = 3.76;
    U[2][2] = 1.4;

    overlap::vecOfvec Uinv(3);
    overlap::vecOfvec Finv(3);
    for (unsigned int i=0; i<Finv.size(); i++){
        Uinv[i] = zeros;
        Finv[i] = zeros;
        Uinv[i][i] = 1./U[i][i];
        for (unsigned int j=0; j<3; j++){
            for (unsigned int k=0; k<3; k++){
                Finv[i][j] += Uinv[i][k]*Qinv[k][j];
            }
        }
    }

    double det_Finv = Finv[0][0]*(Finv[1][1]*Finv[2][2] - Finv[1][2]*Finv[2][1])
                    - Finv[0][1]*(Finv[1][0]*Finv[2][2] - Finv[2][0]*Finv[1][2])
                    + Finv[0][2]*(Finv[1][0]*Finv[2][1] - Finv[2][0]*Finv[1][1]);

    if (!vectorTools::fuzzyEquals(det_Finv, Uinv[0][0]*Uinv[1][1]*Uinv[2][2])){
        results << "test_apply_nansons_relation (Finv doesn't have the correct determinant!) & False\n";
        return;
    }

    std::vector< double > result2;
    overlap::apply_nansons_relation(N, A/det_Finv, Finv, result2);

    std::vector< double > answer2 = {3.2103297, 3.73771722, 1.21871407};


    if (!vectorTools::fuzzyEquals(result2, answer2)){
        results << "test_apply_nansons_relation (test 2) & False\n";
        return;
    }

    //All tests passed
    results << "test_apply_nansons_relation & True\n";
    return;
}

void test_perform_volume_integration(std::ofstream &results){
    /*!
    Test performing volume integration over a domain.
    */

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc = overlap::OverlapCoupling(data.local_nodes, data.local_gpts);
    std::vector< overlap::integrateMap > points;
    oc.compute_weights(data.coordinates, points);

    //Test the computation of the object's volume
    std::map< unsigned int, double > onemap;
//    for (unsigned int i=0; i<data.node_numbers.size(); i++){
//        onemap.insert( std::pair< unsigned int, double >(data.node_numbers[i], 1.));
//    }
    for (auto c = data.coordinates.begin(); c != data.coordinates.end(); c++){
        onemap.insert( std::pair< unsigned int, double >(c->first, 1.));
    }

    std::vector< double > answer1(data.local_gpts.size(), 1.);
    answer1[0] = answer1[2] = answer1[4] = answer1[6] = 0;
    std::vector< double > result1;

    overlap::perform_volume_integration(onemap, points, result1);

    if (!vectorTools::fuzzyEquals(result1, answer1)){
        results << "test_perform_volume_integration (test 1) & False\n";
        return;
    }

    //Test a constant value integration
    std::map< unsigned int, double > constmap;
//    for (unsigned int i=0; i<data.node_numbers.size(); i++){
//        constmap.insert( std::pair< unsigned int, double >(data.node_numbers[i], 3.14159));
//    }
    for (auto c = data.coordinates.begin(); c != data.coordinates.end(); c++){
        constmap.insert( std::pair< unsigned int, double >(c->first, 3.14159));
    }

    std::vector< double > answer2(data.local_gpts.size(), 3.14159);
    answer2[0] = answer2[2] = answer2[4] = answer2[6] = 0;
    std::vector< double > result2;

    overlap::perform_volume_integration(constmap, points, result2);

    if (!vectorTools::fuzzyEquals(result2, answer2)){
        results << "test_perform_volume_integration (test 2) & False\n";
        return;
    }

    //Test a constant value integration of a vector quantity
    std::map< unsigned int, std::vector< double > > constvecmap;
//    for (unsigned int i=0; i<data.node_numbers.size(); i++){
//        constvecmap.insert( std::pair< unsigned int, std::vector< double > >(data.node_numbers[i], {1., 2., -3., 1.42}));
//    }
    for (auto c = data.coordinates.begin(); c != data.coordinates.end(); c++){
        constvecmap.insert( std::pair< unsigned int, std::vector< double > >(c->first, {1., 2., -3., 1.42}));
    }

    overlap::vecOfvec answer3 = {{0., 0., 0., 0.}, {1., 2., -3., 1.42}};
    overlap::vecOfvec result3;
    overlap::perform_volume_integration(constvecmap, points, result3);

    for (unsigned int i=0; i<result3.size(); i++){
        if (!vectorTools::fuzzyEquals(result3[i], answer3[i%2])){
            results << "test_perform_volume_integration (test 3) & False\n";
            return;
        }
    }
    
    //All tests passed.
    results << "test_perform_volume_integration & True\n";
    return;
}

int test_perform_position_weighted_volume_integration(std::ofstream &results){
    /*!
     * Test performing volume integration weighted by the position
     * 
     * :param std::ofstream &results: The output file.
     */

    std::map< unsigned int, double > values;
    getTestScalarValues(values);

    std::vector< overlap::integrateMap > weights;
    getTestWeights(weights);

    overlap::vecOfvec answer = {
        { 0.7575603, 1.3636803, -1.1571165},
        { -0.6229337, -0.9164115, -0.7173426},
        { 1.4834305, -2.2028700, 1.1698280},
    };

    overlap::vecOfvec result;
    overlap::perform_position_weighted_volume_integration(values, weights, result);

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_perform_position_weighted_volume_integration (test 1) & False\n";
        return 1;
    }

    results << "test_perform_position_weighted_volume_integration & True\n";
    return 0;
}

void test_perform_surface_integration(std::ofstream &results){
    /*!
    Test performing surface integration over a domain.
    */

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");
    overlap::OverlapCoupling oc = overlap::OverlapCoupling(data.local_nodes, data.local_gpts);
    std::vector< overlap::integrateMap > points;
//    oc.compute_weights(data.node_numbers, data.coordinates, points);
    oc.compute_weights(data.coordinates, points, true);

    //Test the computation of the surface area of the gauss domains
    std::map< unsigned int, double > onemap;
//    for (unsigned int i=0; i<data.node_numbers.size(); i++){
//        onemap.insert( std::pair< unsigned int, double >(data.node_numbers[i], 1.));
//    }
    for (auto c = data.coordinates.begin(); c != data.coordinates.end(); c++){
        onemap.insert( std::pair< unsigned int, double >(c->first, 1.));
    }

    std::vector< std::map< unsigned int, double > > result1;
    overlap::perform_surface_integration(onemap, points, result1);

    double gd_surface_area;

    for (unsigned int gp=0; gp<result1.size(); gp++){

        gd_surface_area = 0;

        if (result1[gp].size() != 6*(gp%2)){
            results << "test_perform_surface_integration (test 1a) & False\n";
            return;
        }

        for (auto it=result1[gp].begin(); it!=result1[gp].end(); it++){
            gd_surface_area += it->second;
            if (!vectorTools::fuzzyEquals(it->second, 1.)){
                results << "test_perform_surface_integration (test 1b) & False\n";
                return;
            }
        }

        if (!vectorTools::fuzzyEquals(gd_surface_area, 6.*(gp%2))){
            results << "test_perform_surface_integration (test 1c) & False\n";
            return;
        }
    }

    //Test the computation of a constant integrated over the surface of the gauss domains
    std::map< unsigned int, double > constmap;
//    for (unsigned int i=0; i<data.node_numbers.size(); i++){
//        constmap.insert( std::pair< unsigned int, double >(data.node_numbers[i], 3.14159));
//    }
    for (auto c = data.coordinates.begin(); c != data.coordinates.end(); c++){
        constmap.insert( std::pair< unsigned int, double >(c->first, 3.14159));
    }

    std::vector< std::map< unsigned int, double > > result2;
    overlap::perform_surface_integration(constmap, points, result2);

    for (unsigned int gp=0; gp<result2.size(); gp++){
        
        if (result2[gp].size() != 6*(gp%2)){
            results << "test_perform_surface_integration (test 2a) & False\n";
            return;
        }

        for (auto it=result2[gp].begin(); it!=result2[gp].end(); it++){
            if (!vectorTools::fuzzyEquals(it->second, 3.14159)){
                results << "test_perform_surface_integration (test 2b) & False\n";
                return;
            }
        }
    }

    //Test a constant value integration of a vector quantity
    //Test a constant value integration of a vector quantity
    std::map< unsigned int, std::vector< double > > constvecmap;
//    for (unsigned int i=0; i<data.node_numbers.size(); i++){
//        constvecmap.insert( std::pair< unsigned int, std::vector< double > >(data.node_numbers[i], {1., 2., -3., 1.42}));
//    }
    for (auto c = data.coordinates.begin(); c != data.coordinates.end(); c++){
        constvecmap.insert( std::pair< unsigned int, std::vector< double > >(c->first, {1., 2., -3., 1.42}));
    }

    overlap::vecOfvec answer3 = {{0., 0., 0., 0.}, {1., 2., -3., 1.42}};
    std::vector< std::map< unsigned int, std::vector< double > > > result3;
    overlap::perform_surface_integration(constvecmap, points, result3);

    for (unsigned int gp=0; gp<result3.size(); gp++){
        
        if (result3[gp].size() != 6*(gp%2)){
            results << "test_perform_surface_integration (test 3a) & False\n";
            return;
        }

        for (auto it=result3[gp].begin(); it!=result3[gp].end(); it++){
            if (!vectorTools::fuzzyEquals(it->second, answer3[gp%2])){
                results << "test_perform_surface_integration (test 3b) & False\n";
                return;
            }
        }
    }

    results << "test_perform_surface_integration & True\n";
    return;
}

int test_split(std::ofstream &results){
    /*!
     * Test the split function.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::string test = "the, quick, brown, fox";
    std::vector< std::string > answer {"the", " quick", " brown", " fox"};

    std::vector< std::string > result = overlap::split(test, ',');

    if (result.size() != answer.size()){
        results << "test_split (test 1) & False\n";
        return 1;
    }

    unsigned int i=0;
    for (auto r = result.begin(); r != result.end(); r++, i++){
        if (r->compare(answer[i]) != 0){
            results << "test_split (test 2) & False\n";
            return 1;
        }
    }

    results << "test_split & True\n";
    return 0;
}

int test_point_on_surface(std::ofstream &results){
    /*!
     * Test the computation of whether a point is on 
     * a surface or not.
     * 
     * :param std::ofstream &results: The output file.
     */

    if (!overlap::point_on_surface({1, 0, 0}, {1, 0, 0}, {1, 0, 0})){
        results << "test_point_on_surface (test 1) & False\n";
        return 1;
    }

    if (overlap::point_on_surface({1.1, 0, 0}, {1, 0, 0}, {1, 0, 0})){
        results << "test_point_on_surface (test 2) & False\n";
        return 1;
    }

    if (!overlap::point_on_surface({4.3, 7.1, 0.5}, {1, 2, 3}, {2, 3, 4})){
        results << "test_point_on_surface (test 3) & False\n";
        return 1;
    }

    results << "test_point_on_surface & True\n";
    return 0;
}

int test_compute_surface_information(std::ofstream &results){
    /*!
     * Test the computation of the surface information.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::map< unsigned int, double > values;
    getTestScalarValues(values);

    std::vector< overlap::integrateMap > weights;
    getTestWeights(weights);

    overlap::scalar_surface_map expected_surface_area = {
        {
            { 0, 6.6279045},
            { 1, 3.6365401},
            { 2, 5.2787107},
            { 3, 5.9764032},
            { 4, 4.2623198},
            { 5, 5.1575944}
        },
        {
            { 0, 7.3561083},
            { 1, 7.3736988},
            { 2, 4.9883567},
            { 3, 4.1624871},
            { 4, 10.1459643},
            { 5, 3.1319550}
        },
        {
            { 0, 5.5220149},
            { 1, 6.6606564},
            { 2, 3.9224116},
            { 3, 4.8982708},
            { 4, 5.1887084},
            { 5, 2.2297760}
        },
    };

    overlap::vector_surface_map expected_surface_normal = {
        {
            { 0, { +0.9674501, +0.0619480, -0.2453626} },
            { 1, { +0.9541165, -0.2927724, -0.0628173} },
            { 2, { -0.6333563, -0.3554619, +0.6873912} },
            { 3, { -0.5338055, -0.1410125, +0.8337669} },
            { 4, { -0.4073162, +0.6445803, +0.6470006} },
            { 5, { -0.9960542, -0.0885822, +0.0054014} }
        },
        {
            { 0, { +0.9674501, +0.0619480, -0.2453626} },
            { 1, { +0.9541165, -0.2927724, -0.0628173} },
            { 2, { -0.6333563, -0.3554619, +0.6873912} },
            { 3, { -0.5338055, -0.1410125, +0.8337669} },
            { 4, { -0.4073162, +0.6445803, +0.6470006} },
            { 5, { -0.9960542, -0.0885822, +0.0054014} }
        },
        {
            { 0, { +0.9674501, +0.0619480, -0.2453626} },
            { 1, { +0.9541165, -0.2927724, -0.0628173} },
            { 2, { -0.6333563, -0.3554619, +0.6873912} },
            { 3, { -0.5338055, -0.1410125, +0.8337669} },
            { 4, { -0.4073162, +0.6445803, +0.6470006} },
            { 5, { -0.9960542, -0.0885822, +0.0054014} }
        },
    };

    overlap::vector_surface_map expected_surface_centroid = {
        {
            { 0, { +0.6069182, +0.6471638, +0.5012709} },
            { 1, { +0.5611019, +0.2453154, +0.8987228} },
            { 2, { +0.6118775, +0.3908650, +0.7066203} },
            { 3, { +0.5650533, +0.5379503, +0.1885028} },
            { 4, { +0.5433033, +0.5560968, +0.4025441} },
            { 5, { +0.3237673, +0.3666348, +0.2233545} }
        },
        {
            { 0, { +0.5262569, +0.5816638, +0.3820879} },
            { 1, { +0.6094236, +0.8706724, +0.7745495} },
            { 2, { +0.4080556, +0.4338224, +0.7939928} },
            { 3, { +0.3634908, +0.4783595, +0.5075112} },
            { 4, { +0.6348086, +0.6194851, +0.4450820} },
            { 5, { +0.5464156, +0.7289071, +0.3207596} }
        },
        {
            { 0, { +0.4552979, +0.4780967, +0.5188638} },
            { 1, { +0.4556575, +0.6012562, +0.3059876} },
            { 2, { +0.4577223, +0.4192262, +0.5591345} },
            { 3, { +0.8335630, +0.3168244, +0.5406071} },
            { 4, { +0.5982376, +0.6513692, +0.4136412} },
            { 5, { +0.2468041, +0.2626239, +0.3589336} }
        },
    };

    overlap::scalar_surface_map surface_area;
    overlap::vector_surface_map surface_normal;
    overlap::vector_surface_map surface_centroid;
    overlap::compute_surface_information(weights, values, surface_area, surface_normal, surface_centroid);

    for (unsigned int gp = 0; gp < surface_area.size(); gp++){
        for (auto sa = surface_area[gp].begin(); sa != surface_area[gp].end(); sa++){

            auto itsa = expected_surface_area[gp].find(sa->first);

            if (itsa == expected_surface_area[gp].end()){
                results << "test_compute_surface_information (test 1) & False\n";
                return 1;
            }

            if (!vectorTools::fuzzyEquals(itsa->second, sa->second)){
                results << "test_compute_surface_information (test 2) & False\n";
                return 1;
            }
        }
    }

    for (unsigned int gp=0; gp < surface_normal.size(); gp++){
        for (auto sn = surface_normal[gp].begin(); sn != surface_normal[gp].end(); sn++){
        
            auto itsn = expected_surface_normal[gp].find(sn->first);

            if (itsn == expected_surface_normal[gp].end()){
                results << "test_compute_surface_information (test 3) & False\n";
                return 1;
            }

            if (!vectorTools::fuzzyEquals(itsn->second, sn->second)){
                results << "test_compute_surface_information (test 4) & False\n";
                return 1;
            }
        }
    }

    for (unsigned int gp=0; gp < surface_centroid.size(); gp++){
        for (auto sc = surface_centroid[gp].begin(); sc != surface_centroid[gp].end(); sc++){
        
            auto itsc = expected_surface_centroid[gp].find(sc->first);

            if (itsc == expected_surface_centroid[gp].end()){
                results << "test_compute_surface_information (test 5) & False\n";
                return 1;
            }

            if (!vectorTools::fuzzyEquals(itsc->second, sc->second)){
                results << "test_compute_surface_information (test 6) & False\n";
                return 1;
            }
        }
    }

    results << "test_compute_surface_information & True\n";
    return 0;
}

int test_perform_symmetric_tensor_surface_traction_integration(std::ofstream &results){
    /*!
     * Test the computation of symmetric surface traction integration where the traction 
     * is defined via:
     * t_i = A_{ij} n_i = A_{ji} n_i
     * 
     * :param std::ofstream &results: The output file
     */
    std::map< unsigned int, double > values;
    getTestScalarValues(values);

    std::vector< overlap::integrateMap > weights;
    getTestWeights(weights);

    std::map< unsigned int, std::vector< double > > stress;
    getTestStresses(stress);

    std::vector< std::map< unsigned int, std::vector< double > > > tractionAnswer = {
        {
            { 0, { +4.5445938, +4.3381319, +4.2159043} },
            { 1, { +1.5230614, +1.6117824, +1.0373278} },
            { 2, { -2.4010498, -2.6128346, -2.6304693} },
            { 3, { +2.4001277, +0.5015041, +0.0176077} },
            { 4, { +3.3960809, +4.5980876, +4.8779597} },
            { 5, { -5.4820937, -4.3721412, -5.6916784} }
        },
        {
            { 0, { +5.7779670, +6.2925615, +5.1315456} },
            { 1, { +4.0562813, +3.7019694, +3.6858476} },
            { 2, { -1.6220018, -0.0253936, -1.1295883} },
            { 3, { -0.5939212, +2.6018972, -0.2906700} },
            { 4, { +8.2748457, +8.1720873, +10.2289935} },
            { 5, { -5.4254608, -3.6245915, -3.8032176} }
        },
        {
            { 0, { +3.2327857, +3.6792257, +3.9556763} },
            { 1, { +1.9427409, +2.6506859, +4.8496609} },
            { 2, { -0.4424148, -1.3378228, -1.5163992} },
            { 3, { +0.7086401, +1.0492832, +1.1855909} },
            { 4, { +4.1936048, +6.0773082, +5.8506303} },
            { 5, { -2.1676144, -2.6583110, -1.4034769} }
        },
    };

    //Test of the surface traction integration
    std::vector< std::map< unsigned int, std::vector< double > > > result;
    overlap::perform_symmetric_tensor_surface_traction_integration( stress, weights, result);

    for (unsigned int gp = 0; gp < result.size(); gp++){
        for (auto faceResult = result[gp].begin(); faceResult != result[gp].end(); faceResult++){

            auto faceAnswer = tractionAnswer[gp].find(faceResult->first);
            if (faceAnswer == tractionAnswer[gp].end()){
                results << "test_perform_symmetric_tensor_surface_traction_integration (test 1a) & False\n";
                return 1;
            }

            if (!vectorTools::fuzzyEquals(faceAnswer->second, faceResult->second)){
                results << "test_perform_symmetric_tensor_surface_traction_integration (test 1b) & False\n";
                return 1;
            }
        }
    }
    
    results << "test_perform_symmetric_tensor_surface_traction_integration & True\n";
    return 0;
}

int test_perform_symmetric_tensor_surface_couple_traction_integration(std::ofstream &results){
    /*!
     * Test the computation of symmetric surface couple traction integration where the traction 
     * is defined via:
     * t_ik = A_{ij} n_i \xi_k = A_{ji} n_i \xi_k
     * where $\xi_k$ is the relative vector to the centroid of the face.
     * 
     * :param std::ofstream &results: The output file
     */
    std::map< unsigned int, double > values;
    getTestScalarValues(values);

    std::vector< overlap::integrateMap > weights;
    getTestWeights(weights);

    std::map< unsigned int, std::vector< double > > stress;
    getTestStresses(stress);

    std::vector< std::map< unsigned int, std::vector< double > > > faceCentroids = {
        {
            { 0, { +0.6069182, +0.6471638, +0.5012709} },
            { 1, { +0.5611019, +0.2453154, +0.8987228} },
            { 2, { +0.6118775, +0.3908650, +0.7066203} },
            { 3, { +0.5650533, +0.5379503, +0.1885028} },
            { 4, { +0.5433033, +0.5560968, +0.4025441} },
            { 5, { +0.3237673, +0.3666348, +0.2233545} }
        },
        {
            { 0, { +0.5262569, +0.5816638, +0.3820879} },
            { 1, { +0.6094236, +0.8706724, +0.7745495} },
            { 2, { +0.4080556, +0.4338224, +0.7939928} },
            { 3, { +0.3634908, +0.4783595, +0.5075112} },
            { 4, { +0.6348086, +0.6194851, +0.4450820} },
            { 5, { +0.5464156, +0.7289071, +0.3207596} }
        },
        {
            { 0, { +0.4552979, +0.4780967, +0.5188638} },
            { 1, { +0.4556575, +0.6012562, +0.3059876} },
            { 2, { +0.4577223, +0.4192262, +0.5591345} },
            { 3, { +0.8335630, +0.3168244, +0.5406071} },
            { 4, { +0.5982376, +0.6513692, +0.4136412} },
            { 5, { +0.2468041, +0.2626239, +0.3589336} }
        },
    };

    std::vector< std::map< unsigned int, std::vector< double > > > coupleAnswer = {
        {
            { 0, { -0.1411719, -0.3470673, +1.2152740, +0.2829737, +0.1648312, -0.0236729, -1.1342389, -0.0212688, +0.0045740, } },
            { 1, { -0.0349021, -0.0981988, -0.0580667, -0.0071356, -0.0317622, +0.4049377, +0.1460768, -0.1209825, -0.0266523, } },
            { 2, { +0.4733477, +0.2271554, -0.2378853, +0.0677121, +0.1414384, -0.1913797, +0.2296672, -0.1779533, -0.1148433, } },
            { 3, { -0.4853201, -0.3164826, -0.1879234, -0.0626456, +0.0699479, +0.2770538, -0.8030380, +0.0418311, +0.0306294, } },
            { 4, { -0.3589430, -0.1689001, +0.4978581, +0.1534635, +0.2868719, -0.5552265, -0.6824278, -0.3323777, -0.0180161, } },
            { 5, { -0.4518184, -0.5319320, -0.4671859, -0.0974582, -0.7963443, -1.6213136, -0.6959974, -0.2463178, -0.2145748, } }
        },
        {
            { 0, { +1.0245692, +0.1044944, -0.4311816, +0.5641613, +1.0138633, -0.6524804, -0.0807932, +0.2615545, +0.5129964, } },
            { 1, { +0.0866954, -0.1296710, -0.0908149, -0.1842670, -0.2392168, +0.1346914, +0.3317059, +0.6065154, +0.1632610, } },
            { 2, { -0.4518465, -0.3337830, -0.0809544, +0.0540371, -0.2480999, +0.6107591, +0.5566684, -0.5315325, +0.3141794, } },
            { 3, { -0.0828258, +0.3012344, -0.1883659, +0.1312137, -0.0984261, -0.1385878, -0.6248216, -0.1888142, +0.2609854, } },
            { 4, { -0.7047736, +0.2816795, -0.3038518, -0.8101190, +1.1877378, +0.0402800, -0.6970887, +0.3250941, +0.6218357, } },
            { 5, { -0.1509880, -0.3646731, -0.5068330, -0.7470276, -0.4147970, -0.3231446, -0.2794617, -0.1606435, -0.2275765, } }
        },
        {
            { 0, { +0.1873177, -0.1516189, +0.3301209, +0.6104134, +0.5553069, +0.6870022, -0.1992655, +0.1226014, -0.5559339, } },
            { 1, { +0.1329959, -0.4354636, +0.1653832, +0.1458539, +0.6496669, -1.1274522, -0.3059052, +0.1918284, +0.3401151, } },
            { 2, { -0.1437614, -0.0698570, -0.1899879, +0.0292881, +0.3249585, -0.5130343, +0.2421967, +0.1861662, +0.0288046, } },
            { 3, { +0.1368169, +0.2200558, -0.0313283, +0.0671793, -0.0818094, -0.2146196, +0.0020916, +0.6920766, -0.0927662, } },
            { 4, { +0.3035478, -0.0135429, +0.4026860, +0.1118448, +0.0070200, -0.1338019, -0.2211503, -0.5115117, +0.0822689, } },
            { 5, { -0.0632938, +0.0951620, -0.1253210, -0.1648222, -0.0303948, +0.1505645, -0.1093462, +0.0364971, -0.0493587, } }
        },
    };

    //Test of the surface couple integration
    std::vector< std::map< unsigned int, std::vector< double > > > result;
    overlap::perform_symmetric_tensor_surface_couple_traction_integration( stress, weights, faceCentroids, result);
    for (unsigned int gp = 0; gp < result.size(); gp++){
        for (auto faceResult = result[gp].begin(); faceResult != result[gp].end(); faceResult++){

            auto faceAnswer = coupleAnswer[gp].find(faceResult->first);
            if (faceAnswer == coupleAnswer[gp].end()){
                results << "test_perform_symmetric_tensor_surface_couple_traction_integration (test 1a) & False\n";
                return 1;
            }

            if (!vectorTools::fuzzyEquals(faceAnswer->second, faceResult->second)){
                results << "test_perform_symmetric_tensor_surface_couple_traction_integration (test 1b) & False\n";
                return 1;
            }
        }
    }
    
    results << "test_perform_symmetric_tensor_surface_couple_traction_integration & True\n";
    return 0;
}

int test_construct_linear_momentum_surface_external_force(std::ofstream &results){
    /*!
     * Test the construction of the linear momentum external force from surface 
     * tractions.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< std::map< unsigned int, std::vector< double > > > face_shapefunctions = {
        {
            { 0, { +0.0157454, +0.0300936, +0.3390992, +0.8209689, } },
            { 1, { +0.4588211, +0.0148406, +0.1632200, +0.7399227, } },
            { 2, { +0.7382937, +0.7545229, +0.3516694, +0.3522769, } },
            { 3, { +0.8020757, +0.3981379, +0.7271910, +0.5811230, } },
            { 4, { +0.3643417, +0.0800065, +0.1161254, +0.8895587, } },
            { 5, { +0.4523405, +0.9940045, +0.3638969, +0.2499543, } }
        },
        {
            { 0, { +0.3505393, +0.3430861, +0.6373567, +0.0127376, } },
            { 1, { +0.7632686, +0.4164146, +0.4322392, +0.4811150, } },
            { 2, { +0.4492124, +0.4974709, +0.3459043, +0.4533461, } },
            { 3, { +0.4046513, +0.5182427, +0.6232691, +0.2410406, } },
            { 4, { +0.5084371, +0.5946219, +0.0169483, +0.5204937, } },
            { 5, { +0.2392932, +0.4045385, +0.8265302, +0.3262356, } }
        },
        {
            { 0, { +0.4832169, +0.0247412, +0.3087509, +0.6397211, } },
            { 1, { +0.3151618, +0.2057975, +0.2906557, +0.9543783, } },
            { 2, { +0.0868018, +0.4633578, +0.0583869, +0.5386582, } },
            { 3, { +0.1460357, +0.6340848, +0.2643975, +0.6909154, } },
            { 4, { +0.3471461, +0.0041685, +0.2948947, +0.0818944, } },
            { 5, { +0.4950396, +0.2888901, +0.6399919, +0.4999359, } }
        },
    };

    std::vector< std::map< unsigned int, std::vector< double > > > face_tractions = {
        {
            { 0, { +4.5445938, +4.3381319, +4.2159043} },
            { 1, { +1.5230614, +1.6117824, +1.0373278} },
            { 2, { -2.4010498, -2.6128346, -2.6304693} },
            { 3, { +2.4001277, +0.5015041, +0.0176077} },
            { 4, { +3.3960809, +4.5980876, +4.8779597} },
            { 5, { -5.4820937, -4.3721412, -5.6916784} }
        },
        {
            { 0, { +5.7779670, +6.2925615, +5.1315456} },
            { 1, { +4.0562813, +3.7019694, +3.6858476} },
            { 2, { -1.6220018, -0.0253936, -1.1295883} },
            { 3, { -0.5939212, +2.6018972, -0.2906700} },
            { 4, { +8.2748457, +8.1720873, +10.2289935} },
            { 5, { -5.4254608, -3.6245915, -3.8032176} }
        },
        {
            { 0, { +3.2327857, +3.6792257, +3.9556763} },
            { 1, { +1.9427409, +2.6506859, +4.8496609} },
            { 2, { -0.4424148, -1.3378228, -1.5163992} },
            { 3, { +0.7086401, +1.0492832, +1.1855909} },
            { 4, { +4.1936048, +6.0773082, +5.8506303} },
            { 5, { -2.1676144, -2.6583110, -1.4034769} }
        },
    };

    std::vector< std::map< unsigned int, double > > face_areas = {
        {
            { 0, 6.6279045},
            { 1, 3.6365401},
            { 2, 5.2787107},
            { 3, 5.9764032},
            { 4, 4.2623198},
            { 5, 5.1575944}
        },
        {
            { 0, 7.3561083},
            { 1, 7.3736988},
            { 2, 4.9883567},
            { 3, 4.1624871},
            { 4, 10.1459643},
            { 5, 3.1319550}
        },
        {
            { 0, 5.5220149},
            { 1, 6.6606564},
            { 2, 3.9224116},
            { 3, 4.8982708},
            { 4, 5.1887084},
            { 5, 2.2297760}
        },
    };
    
    std::vector< std::vector< unsigned int > > external_face_ids = {
        {  2,  4,  1 },
        {  0,  2,  4 },
        {  3,  0,  1 },
    };

    std::vector< double > expectedResult = {65.61988646,  74.10479359,  84.1060304 ,  57.46225634,
                                            63.76370357,  73.97233703,  34.03218427,  42.00943465,
                                            39.68427039,  79.24964066,  93.99842145, 117.15383048};

    std::vector< double > result;
    overlap::construct_linear_momentum_surface_external_force(face_shapefunctions, face_tractions, face_areas, external_face_ids, result);

    if (!vectorTools::fuzzyEquals(result, expectedResult)){
        results << "test_construct_linear_momentum_surface_external_force (test 1) & False\n";
        return 1;
    }

    results << "test_construct_linear_momentum_surface_external_force & True\n";
    return 0;
}

int test_construct_first_moment_surface_external_couple(std::ofstream &results){
    /*!
     * Test the construction of the external couple from surface 
     * couples.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< std::map< unsigned int, std::vector< double > > > face_shapefunctions = {
        {
            { 0, { +0.0157454, +0.0300936, +0.3390992, +0.8209689, } },
            { 1, { +0.4588211, +0.0148406, +0.1632200, +0.7399227, } },
            { 2, { +0.7382937, +0.7545229, +0.3516694, +0.3522769, } },
            { 3, { +0.8020757, +0.3981379, +0.7271910, +0.5811230, } },
            { 4, { +0.3643417, +0.0800065, +0.1161254, +0.8895587, } },
            { 5, { +0.4523405, +0.9940045, +0.3638969, +0.2499543, } }
        },
        {
            { 0, { +0.3505393, +0.3430861, +0.6373567, +0.0127376, } },
            { 1, { +0.7632686, +0.4164146, +0.4322392, +0.4811150, } },
            { 2, { +0.4492124, +0.4974709, +0.3459043, +0.4533461, } },
            { 3, { +0.4046513, +0.5182427, +0.6232691, +0.2410406, } },
            { 4, { +0.5084371, +0.5946219, +0.0169483, +0.5204937, } },
            { 5, { +0.2392932, +0.4045385, +0.8265302, +0.3262356, } }
        },
        {
            { 0, { +0.4832169, +0.0247412, +0.3087509, +0.6397211, } },
            { 1, { +0.3151618, +0.2057975, +0.2906557, +0.9543783, } },
            { 2, { +0.0868018, +0.4633578, +0.0583869, +0.5386582, } },
            { 3, { +0.1460357, +0.6340848, +0.2643975, +0.6909154, } },
            { 4, { +0.3471461, +0.0041685, +0.2948947, +0.0818944, } },
            { 5, { +0.4950396, +0.2888901, +0.6399919, +0.4999359, } }
        },
    };

    std::vector< std::map< unsigned int, std::vector< double > > > face_couples = {
        {
            { 0, { -0.1411719, -0.3470673, +1.2152740, +0.2829737, +0.1648312, -0.0236729, -1.1342389, -0.0212688, +0.0045740, } },
            { 1, { -0.0349021, -0.0981988, -0.0580667, -0.0071356, -0.0317622, +0.4049377, +0.1460768, -0.1209825, -0.0266523, } },
            { 2, { +0.4733477, +0.2271554, -0.2378853, +0.0677121, +0.1414384, -0.1913797, +0.2296672, -0.1779533, -0.1148433, } },
            { 3, { -0.4853201, -0.3164826, -0.1879234, -0.0626456, +0.0699479, +0.2770538, -0.8030380, +0.0418311, +0.0306294, } },
            { 4, { -0.3589430, -0.1689001, +0.4978581, +0.1534635, +0.2868719, -0.5552265, -0.6824278, -0.3323777, -0.0180161, } },
            { 5, { -0.4518184, -0.5319320, -0.4671859, -0.0974582, -0.7963443, -1.6213136, -0.6959974, -0.2463178, -0.2145748, } }
        },
        {
            { 0, { +1.0245692, +0.1044944, -0.4311816, +0.5641613, +1.0138633, -0.6524804, -0.0807932, +0.2615545, +0.5129964, } },
            { 1, { +0.0866954, -0.1296710, -0.0908149, -0.1842670, -0.2392168, +0.1346914, +0.3317059, +0.6065154, +0.1632610, } },
            { 2, { -0.4518465, -0.3337830, -0.0809544, +0.0540371, -0.2480999, +0.6107591, +0.5566684, -0.5315325, +0.3141794, } },
            { 3, { -0.0828258, +0.3012344, -0.1883659, +0.1312137, -0.0984261, -0.1385878, -0.6248216, -0.1888142, +0.2609854, } },
            { 4, { -0.7047736, +0.2816795, -0.3038518, -0.8101190, +1.1877378, +0.0402800, -0.6970887, +0.3250941, +0.6218357, } },
            { 5, { -0.1509880, -0.3646731, -0.5068330, -0.7470276, -0.4147970, -0.3231446, -0.2794617, -0.1606435, -0.2275765, } }
        },
        {
            { 0, { +0.1873177, -0.1516189, +0.3301209, +0.6104134, +0.5553069, +0.6870022, -0.1992655, +0.1226014, -0.5559339, } },
            { 1, { +0.1329959, -0.4354636, +0.1653832, +0.1458539, +0.6496669, -1.1274522, -0.3059052, +0.1918284, +0.3401151, } },
            { 2, { -0.1437614, -0.0698570, -0.1899879, +0.0292881, +0.3249585, -0.5130343, +0.2421967, +0.1861662, +0.0288046, } },
            { 3, { +0.1368169, +0.2200558, -0.0313283, +0.0671793, -0.0818094, -0.2146196, +0.0020916, +0.6920766, -0.0927662, } },
            { 4, { +0.3035478, -0.0135429, +0.4026860, +0.1118448, +0.0070200, -0.1338019, -0.2211503, -0.5115117, +0.0822689, } },
            { 5, { -0.0632938, +0.0951620, -0.1253210, -0.1648222, -0.0303948, +0.1505645, -0.1093462, +0.0364971, -0.0493587, } }
        },
    };

    std::vector< std::map< unsigned int, double > > face_areas = {
        {
            { 0, 6.6279045},
            { 1, 3.6365401},
            { 2, 5.2787107},
            { 3, 5.9764032},
            { 4, 4.2623198},
            { 5, 5.1575944}
        },
        {
            { 0, 7.3561083},
            { 1, 7.3736988},
            { 2, 4.9883567},
            { 3, 4.1624871},
            { 4, 10.1459643},
            { 5, 3.1319550}
        },
        {
            { 0, 5.5220149},
            { 1, 6.6606564},
            { 2, 3.9224116},
            { 3, 4.8982708},
            { 4, 5.1887084},
            { 5, 2.2297760}
        },
    };
    
    std::vector< std::vector< unsigned int > > external_face_ids = {
        {  2,  4,  1 },
        {  0,  2,  4 },
        {  3,  0,  1 },
    };

    std::vector< double > expectedResult = {0.09978674,  0.27242922, -1.90590302, -0.12991247, 11.91616066,
                                           -1.72563499, -3.65025575,  0.97372731,  3.87880156, -0.39355779,
                                            2.04248692, -3.72857793, -2.515927  , 10.48047889, -2.93598641,
                                           -2.7781775 ,  2.9029572 ,  5.46302997,  5.33715961, -0.57433483,
                                           -1.60072705,  4.20648743,  7.01384136, -3.6774402 , -0.29210774,
                                            1.27506477,  2.40676281, -3.25216437, -2.29875388,  1.57242361,
                                           -0.10368611, 12.88609343, -5.30513919, -6.83870768,  2.61727185,
                                            3.5730709};

    std::vector< double > result;
    overlap::construct_first_moment_surface_external_couple(face_shapefunctions, face_couples, face_areas, external_face_ids, result);

    if (!vectorTools::fuzzyEquals(result, expectedResult)){
        results << "test_construct_first_moment_surface_external_couple (test 1) & False\n";
        return 1;
    }

    results << "test_construct_first_moment_surface_external_couple & True\n";
    return 0;
}

int test_construct_first_moment_symm_cauchy_couple(std::ofstream &results){
    /*!
     * Test the construction of the cauchy - symmetric micro stress 
     * couple at the nodes.
     * 
     * :param std::ofstream &results: The output file.
     */

    overlap::vecOfvec com_shapefunctions = {
        { +0.6964692, +0.2861393, +0.2268515 },
        { +0.5513148, +0.7194690, +0.4231065 },
        { +0.9807642, +0.6848297, +0.4809319 },
        { +0.3921175, +0.3431780, +0.7290497 },
        { +0.4385722, +0.0596779, +0.3980443 },
    };

    overlap::vecOfvec symmetric_microstress = {
        { +0.7379954, +0.5318276, +0.6110235, +0.6344010, +0.1754518, +0.1824917, +0.7244553, +0.8494318, +0.5315514 },
        { +0.7224434, +0.2937140, +0.4308628, +0.6309761, +0.3617887, +0.3229589, +0.4337012, +0.0921049, +0.2282632 },
        { +0.4936851, +0.8933892, +0.1156184, +0.9441600, +0.3122612, +0.4258303, +0.6239530, +0.5018367, +0.4263513 },
        { +0.3172855, +0.4830343, +0.1206287, +0.9855598, +0.8663092, +0.4148262, +0.6128945, +0.5194851, +0.2504554 },
        { +0.8263408, +0.3041208, +0.5104223, +0.4170222, +0.5450680, +0.6030601, +0.8754568, +0.6813008, +0.3427638 },
    };

    overlap::vecOfvec cauchy_stress = {
        { +0.6693138, +0.8423424, +0.1942230, +0.0831950, +0.6249035, +0.5859366, +0.2436664, +0.7636828, +0.6746891 },
        { +0.5724570, +0.7234164, +0.1589596, +0.0161292, +0.8853268, +0.0957125, +0.5567852, +0.5944319, +0.6272490 },
        { +0.1530705, +0.5543832, +0.3573976, +0.3889506, +0.3187664, +0.6955295, +0.8416700, +0.9251325, +0.6919703 },
        { +0.0435915, +0.9953585, +0.6917018, +0.3559149, +0.3981857, +0.3047681, +0.5931769, +0.7625478, +0.7049588 },
        { +0.1511275, +0.5131282, +0.3219806, +0.6666246, +0.2408559, +0.3988763, +0.1308950, +0.1059085, +0.3434560 },
    };

    std::vector< double > volume = {0.66156434, 0.84650623, 0.55325734, 0.85445249, 0.38483781};

    std::vector< double > result;
    overlap::construct_first_moment_symm_cauchy_couple(com_shapefunctions, symmetric_microstress, cauchy_stress, volume, result);

    std::vector< double > answer = {-0.49212763,  0.3665894 , -0.02821591, -0.17822198,  0.40893159,
                                     0.54868035, -1.01101414,  0.24676212,  0.15484332, -0.32916511,
                                     0.3470677 ,  0.0102359 ,  0.04355788,  0.50814221,  0.50402141,
                                    -0.86806591,  0.26214466,  0.00319487, -0.42858277,  0.4614645 ,
                                     0.23127222, -0.09647797,  0.34294884,  0.51829261, -0.80466309,
                                    -0.08151722, -0.04891885};

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_construct_first_moment_symm_cauchy_couple (test 1) & False\n";
        return 1;
    }

    results << "test_construct_first_moment_symm_cauchy_couple & True\n";
    return 0;
}

int test_solve_constrained_least_squares(std::ofstream &results){
    /*!
     * Test solving a constrained least squares problem.
     * 
     * :param std::ofstream &results: The output file.
     */

    Eigen::MatrixXd A(10, 7);
    A << 3.15570361e-02,  9.98613587e-02,  3.16008479e-01,  1.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  1.04522130e+01,
         3.23298824e+00,  1.00000000e+00,  1.12294168e+00,  1.08036739e+00,
         1.03940723e+00,  1.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  3.45108677e-03,  2.28369054e-02,  1.51118845e-01,
         1.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
        -3.51211077e+00,  2.31053279e+00, -1.52004368e+00,  1.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00, -5.69728423e+01,
         1.48062561e+01, -3.84788983e+00,  1.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00, -2.07395645e+01,  7.54860016e+00,
        -2.74747159e+00,  1.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  1.55099599e+01,  3.93826864e+00,  1.00000000e+00,
        -6.22906610e+01,  1.57138267e+01, -3.96406694e+00,  1.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  1.53245730e+01,
         3.91466129e+00,  1.00000000e+00;

    Eigen::MatrixXd C(3, 7);
    C << 4.096,  2.56 ,  1.6  ,  1.   , -2.56 , -1.6  , -1.   ,  7.68 ,
         3.2  ,  1.   ,  0.   , -3.2  , -1.   ,  0.   ,  9.6  ,  2.   ,
         0.   ,  0.   , -2.   ,  0.   ,  0.;
    
    Eigen::MatrixXd b(10, 1);
    b << 0.82068016, -1.28276365, -0.31744071, -0.04326767,  2.22835969,
         3.53802352,  3.83707903, -0.5635042 ,  2.57105067, -0.6044803;

    Eigen::MatrixXd d(3, 1);
    d << 0, 0, 0;

    std::vector< double > answer = {0.06001266,  0.05867046, -1.30001119,  0.70108313,  0.34673124,
                                   -1.76090845,  0.946895};

    Eigen::MatrixXd xmat(7, 1);
    overlap::solve_constrained_least_squares(A, b, C, d, xmat);

    std::vector< double > x(xmat.data(), xmat.data() + xmat.rows() * xmat.cols());

    if (!vectorTools::fuzzyEquals(answer, x)){
        results << "test_solve_constrained_least_squares (test 1) & False\n";
        return 1;
    }
    results << "test_solve_constrained_least_squares & True\n";
    return 1;
}

int test_id_unique_vectors(std::ofstream &results){
    /*!
     * Test the function which ids unique vectors.
     * 
     * :std::ofstream &results: The output file
     */

    std::map< unsigned int, std::vector< double > > vectors = {
        {1, { 1, 2, 3}},
        {2, {-1, 2, 3}},
        {3, { 2, 4, 6}},
    };

    std::map< unsigned int, std::vector< double > > answer = {
        {1, { 1, 2, 3}},
        {2, {-1, 2, 3}},
    };

    std::map< unsigned int, std::vector< double > > result;

    overlap::id_unique_vectors(vectors, result);

    for (auto v = answer.begin(); v != answer.end(); v++){

        auto w = result.find(v->first);

        if (w == result.end()){
            results << "test_id_unique_vectors (test 1a) & False\n";
            return 1;
        }

        if (!vectorTools::fuzzyEquals(w->second, v->second)){
            results << "test_id_unique_vectors (test 1b) & False\n";
            return 1;
        }
    }

    results << "test_id_unique_vectors & True\n";
    return 0;
}

int test_first_moment_cauchy_matrix(std::ofstream &results){
    /*!
     * Test the function which constructs the first moment cauchy interpolation 
     * matrix.
     * 
     * :param std::ofstream &results: The output file.
     */

    overlap::vecOfvec com_shapefunctions = {
        { +0.6964692, +0.2861393, +0.2268515 },
        { +0.5513148, +0.7194690, +0.4231065 },
        { +0.9807642, +0.6848297, +0.4809319 },
        { +0.3921175, +0.3431780, +0.7290497 },
        { +0.4385722, +0.0596779, +0.3980443 },
    };

    std::vector< double > volumes = {0.66156434, 0.84650623, 0.55325734, 0.85445249, 0.38483781};

    Eigen::MatrixXd A;
    overlap::first_moment_cauchy_matrix(com_shapefunctions, volumes, A);

    std::vector< double > cauchyVector = {0.66931378, 0.84234244, 0.19422296, 0.08319499, 0.6249035 ,
                                          0.58593655, 0.24366637, 0.76368284, 0.67468905, 0.57245696,
                                          0.72341636, 0.15895964, 0.01612921, 0.88532683, 0.09571252,
                                          0.55678519, 0.59443188, 0.62724897, 0.15307052, 0.55438325,
                                          0.35739757, 0.38895057, 0.31876643, 0.69552953, 0.84167   ,
                                          0.92513249, 0.6919703 , 0.04359146, 0.99535848, 0.6917018 ,
                                          0.35591487, 0.39818568, 0.30476807, 0.59317692, 0.76254781,
                                          0.70495883, 0.15112745, 0.51312815, 0.32198061, 0.66662455,
                                          0.2408559 , 0.39887629, 0.13089495, 0.10590849, 0.34345601};

    if ((A.rows() != 3 * 9) || (A.cols() != 5 * 9)){
        results << "test_first_moment_cauchy_matrix (test 1a) & False\n";
        return 1;
    }

    Eigen::Map< Eigen::Matrix< double, -1, -1 > > c(cauchyVector.data(), A.cols(), 1);
    std::vector< double > result(A.rows(), 0);
    Eigen::Map< Eigen::Matrix< double, -1, -1 > > r(result.data(), A.rows(), 1);
    r = A * c;

    std::vector< double > answer = {-0.69872386, -1.44664187, -0.64369979, -1.0496549 , -1.40464446,
                                    -1.27323603, -0.48867075, -1.04813376, -0.86148188, -0.54959669,
                                    -1.11374252, -0.47921357, -0.88106851, -1.08314908, -0.98651602,
                                    -0.29261495, -0.90055673, -0.53126461, -0.3965147 , -1.23167552,
                                    -0.66138709, -0.84950237, -1.06491618, -1.00178826, -0.44558235,
                                    -0.7806313 , -0.55823456};

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_first_moment_cauchy_matrix (test 1b) & False\n";
        return 1;
    }

    results << "test_first_moment_cauchy_matrix & True\n";
    return 1;
}

int test_firstMomentHostressMatrix(std::ofstream &results){
    /*!
     * Test the function which constructs the first moment higher order stress 
     * interpolation matrix.
     * 
     * :param std::ofstream &results: The output file.
     */
    
    std::vector< overlap::vecOfvec > com_shape_function_gradients = {
        {
            { +0.3427638, +0.3041208, +0.4170222},
            { +0.6813008, +0.8754568, +0.5104223},
            { +0.6693138, +0.5859366, +0.6249035},
            { +0.6746891, +0.8423424, +0.0831950},
            { +0.7636828, +0.2436664, +0.1942230}
        },
        {
            { +0.5724570, +0.0957125, +0.8853268},
            { +0.6272490, +0.7234164, +0.0161292},
            { +0.5944319, +0.5567852, +0.1589596},
            { +0.1530705, +0.6955295, +0.3187664},
            { +0.6919703, +0.5543832, +0.3889506}
        },
    };

    std::vector< double > volumes = {0.92513249, 0.84167};

    Eigen::MatrixXd A;
    overlap::firstMomentHostressMatrix(com_shape_function_gradients, volumes, A);

    std::vector< double > hoVector = {0.69646919, 0.71946897, 0.4809319 , 0.42310646, 0.22685145,
                                      0.28613933, 0.68482974, 0.9807642 , 0.55131477, 0.39211752,
                                      0.0596779 , 0.17545176, 0.39804426, 0.72904971, 0.34317802,
                                      0.18249173, 0.73799541, 0.43857224, 0.53155137, 0.72445532,
                                      0.36178866, 0.61102351, 0.63440096, 0.53182759, 0.32295891,
                                      0.72244338, 0.84943179, 0.22826323, 0.43370117, 0.31226122,
                                      0.43086276, 0.63097612, 0.29371405, 0.42583029, 0.4936851 ,
                                      0.09210494, 0.42635131, 0.62395295, 0.86630916, 0.1156184 ,
                                      0.94416002, 0.89338916, 0.41482621, 0.31728548, 0.50183668,
                                      0.25045537, 0.61289453, 0.54506801, 0.12062867, 0.98555979,
                                      0.48303426, 0.60306013, 0.8263408 , 0.51948512};

    if ((A.rows() != 5 * 9) || (A.cols() != 2 * 27)){
        results << "test_firstMomentHostressMatrix (test 1a) & False\n";
        return 1;
    }

    Eigen::Map< Eigen::Matrix< double, -1, -1 > > h(hoVector.data(), A.cols(), 1);
    std::vector< double > result(A.rows(), 0);
    Eigen::Map< Eigen::Matrix< double, -1, -1 > > r(result.data(), A.rows(), 1);
    r = A * h;

    std::vector< double > answer = {0.86720323, 1.24036162, 0.96784767, 0.78869087, 1.6362767 ,
                                    0.96589034, 1.08106636, 1.6765356 , 1.09782868, 1.39106868,
                                    1.46110254, 1.31579875, 1.17709636, 1.9543926 , 1.41501437,
                                    1.21752685, 2.02206603, 1.46503951, 1.29862408, 1.48805881,
                                    1.23719115, 1.11688921, 1.79242931, 1.30090814, 1.19781449,
                                    1.93124036, 1.42094459, 1.12739339, 1.13691929, 1.15837048,
                                    0.77686685, 1.65698647, 1.17739808, 1.05402603, 1.71392675,
                                    1.19628597, 1.08983653, 1.39631035, 1.20886868, 0.84282399,
                                    1.56928816, 1.12113442, 1.22199723, 1.69518213, 1.09886693};

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_firstMomentHostressMatrix (test 1b) & False\n";
        return 1;
    }


    results << "test_firstMomentHostressMatrix & True\n";
    return 0;
}

int test_full_first_moment_matrix(std::ofstream &results){
    /*!
     * Test the computation of the full left hand side matrix for the 
     * first moment of momentum part of the determination of the cauchy 
     * and higher-order stresses.
     * 
     * :param std::ofstream &results: The output file.
     */

    overlap::vecOfvec com_shape_functions = {
        { +0.6964692, +0.2861393, +0.2268515, +0.5513148 },
        { +0.7194690, +0.4231065, +0.9807642, +0.6848297 },
    };

    std::vector< overlap::vecOfvec > com_shape_function_gradients = {
        {
            { +0.3427638, +0.3041208, +0.4170222},
            { +0.6813008, +0.8754568, +0.5104223},
            { +0.6693138, +0.5859366, +0.6249035},
            { +0.6746891, +0.8423424, +0.0831950}
        },
        {
            { +0.7636828, +0.2436664, +0.1942230},
            { +0.5724570, +0.0957125, +0.8853268},
            { +0.6272490, +0.7234164, +0.0161292},
            { +0.5944319, +0.5567852, +0.1589596}
        },
    };

    std::vector< double > volume = {0.86630916, 0.25045537};

    Eigen::MatrixXd A;
    overlap::full_first_moment_matrix(com_shape_functions, com_shape_function_gradients, volume, A);

    if ((A.rows() != 9 * 4) || (A.cols() != (9 * 2 + 27 * 2))){
        results << "test_full_first_moment_matrix (test 1a) & False\n";
        return 1;
    }

    std::vector< double > stressVector = {0.36178866, 0.09210494, 0.42583029, 0.43370117, 0.29371405,
                                          0.22826323, 0.4936851 , 0.43086276, 0.63097612, 0.31226122,
                                          0.50183668, 0.41482621, 0.62395295, 0.89338916, 0.42635131,
                                          0.31728548, 0.1156184 , 0.94416002, 0.69646919, 0.71946897,
                                          0.4809319 , 0.42310646, 0.22685145, 0.28613933, 0.68482974,
                                          0.9807642 , 0.55131477, 0.39211752, 0.0596779 , 0.17545176,
                                          0.39804426, 0.72904971, 0.34317802, 0.18249173, 0.73799541,
                                          0.43857224, 0.53155137, 0.72445532, 0.36178866, 0.61102351,
                                          0.63440096, 0.53182759, 0.32295891, 0.72244338, 0.84943179,
                                          0.22826323, 0.43370117, 0.31226122, 0.43086276, 0.63097612,
                                          0.29371405, 0.42583029, 0.4936851 , 0.09210494, 0.42635131,
                                          0.62395295, 0.86630916, 0.1156184 , 0.94416002, 0.89338916,
                                          0.41482621, 0.31728548, 0.50183668, 0.25045537, 0.61289453,
                                          0.54506801, 0.12062867, 0.98555979, 0.48303426, 0.60306013,
                                          0.8263408 , 0.51948512};

    std::vector< double > answer = {0.30945725,  0.49593053,  0.12716741,  0.19154371,  0.43407781,
                                   -0.04912658,  0.1300972 ,  0.56244649,  0.44509074,  0.91920975,
                                    0.92727425,  0.61377877,  0.75708681,  1.17991221,  0.5784928 ,
                                    0.71649904,  1.55216144,  1.07228067,  0.85695191,  0.88194373,
                                    0.58641329,  0.69232763,  1.00613984,  0.48205847,  0.57055081,
                                    1.19559906,  0.96004416,  0.60858558,  0.56219888,  0.34967185,
                                    0.37666636,  0.74954836,  0.18024239,  0.38781578,  1.02098032,
                                    0.62572454};

    Eigen::Map< Eigen::Matrix< double, -1, -1 > > s(stressVector.data(), A.cols(), 1);
    std::vector< double > result(A.rows(), 0);
    Eigen::Map< Eigen::Matrix< double, -1, -1 > > r(result.data(), A.rows(), 1);
    r = A * s;

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_full_first_moment_matrix (test 1b) & False\n";
        return 1;
    }

    results << "test_full_first_moment_matrix & True\n";
    return 0;
}

int test_linear_momentum_cauchy_matrix(std::ofstream &results){
    /*!
     * Test the computation of the matrix which converts the cauchy 
     * stress to the internal force ( N_{,i} \sigma_{ij} ) in the 
     * balance of linear momentum. 
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< overlap::vecOfvec > com_shape_function_gradients = {
        {
            { +0.3427638, +0.3041208, +0.4170222},
            { +0.6813008, +0.8754568, +0.5104223},
            { +0.6693138, +0.5859366, +0.6249035},
            { +0.6746891, +0.8423424, +0.0831950}
        },
        {
            { +0.7636828, +0.2436664, +0.1942230},
            { +0.5724570, +0.0957125, +0.8853268},
            { +0.6272490, +0.7234164, +0.0161292},
            { +0.5944319, +0.5567852, +0.1589596}
        },
    };

    std::vector< double > volume = {0.86630916, 0.25045537};

    Eigen::MatrixXd A;
    overlap::linear_momentum_cauchy_matrix(com_shape_function_gradients, volume, A);

    if ((A.rows() != 3 * 4) || (A.cols() != (9 * 2))){
        results << "test_linear_momentum_cauchy_matrix (test 1a) & False\n";
        return 1;
    }

    std::vector< double > cauchyVector = {0.36178866, 0.09210494, 0.42583029, 0.43370117, 0.29371405,
                                          0.22826323, 0.4936851 , 0.43086276, 0.63097612, 0.31226122,
                                          0.50183668, 0.41482621, 0.62395295, 0.89338916, 0.42635131,
                                          0.31728548, 0.1156184 , 0.94416002};

    std::vector< double > answer = {0.55229547, 0.39800778, 0.58445349, 0.97563702, 0.56638939,
                                    0.92560448, 0.98390231, 0.60555346, 0.87605526, 0.88571157,
                                    0.38229773, 0.75537961};

    Eigen::Map< Eigen::Matrix< double, -1, -1 > > c(cauchyVector.data(), A.cols(), 1);
    std::vector< double > result(A.rows(), 0);
    Eigen::Map< Eigen::Matrix< double, -1, -1 > > r(result.data(), A.rows(), 1);
    r = A * c;

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_linear_momentum_cauchy_matrix (test 1b) & False\n";
        return 1;
    }

    results << "test_linear_momentum_cauchy_matrix & True\n";
    return 0;
}

int test_full_linear_momentum_matrix(std::ofstream &results){
    /*!
     * Test the computation of the matrix which converts the cauchy 
     * stress and higher order stress to the internal force 
     * ( N_{,i} \sigma_{ij} ) in the balance of linear momentum. 
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< overlap::vecOfvec > com_shape_function_gradients = {
        {
            { +0.3427638, +0.3041208, +0.4170222},
            { +0.6813008, +0.8754568, +0.5104223},
            { +0.6693138, +0.5859366, +0.6249035},
            { +0.6746891, +0.8423424, +0.0831950}
        },
        {
            { +0.7636828, +0.2436664, +0.1942230},
            { +0.5724570, +0.0957125, +0.8853268},
            { +0.6272490, +0.7234164, +0.0161292},
            { +0.5944319, +0.5567852, +0.1589596}
        },
    };

    std::vector< double > volume = {0.86630916, 0.25045537};

    Eigen::MatrixXd A;
    overlap::full_linear_momentum_matrix(com_shape_function_gradients, volume, A);

    if ((A.rows() != 3 * 4) || (A.cols() != (9 * 2 + 27 * 2))){
        results << "test_linear_momentum_cauchy_matrix (test 1a) & False\n";
        return 1;
    }

    std::vector< double > stressVector = {0.36178866, 0.09210494, 0.42583029, 0.43370117, 0.29371405,
                                          0.22826323, 0.4936851 , 0.43086276, 0.63097612, 0.31226122,
                                          0.50183668, 0.41482621, 0.62395295, 0.89338916, 0.42635131,
                                          0.31728548, 0.1156184 , 0.94416002, 0.69646919, 0.71946897,
                                          0.4809319 , 0.42310646, 0.22685145, 0.28613933, 0.68482974,
                                          0.9807642 , 0.55131477, 0.39211752, 0.0596779 , 0.17545176,
                                          0.39804426, 0.72904971, 0.34317802, 0.18249173, 0.73799541,
                                          0.43857224, 0.53155137, 0.72445532, 0.36178866, 0.61102351,
                                          0.63440096, 0.53182759, 0.32295891, 0.72244338, 0.84943179,
                                          0.22826323, 0.43370117, 0.31226122, 0.43086276, 0.63097612,
                                          0.29371405, 0.42583029, 0.4936851 , 0.09210494, 0.42635131,
                                          0.62395295, 0.86630916, 0.1156184 , 0.94416002, 0.89338916,
                                          0.41482621, 0.31728548, 0.50183668, 0.25045537, 0.61289453,
                                          0.54506801, 0.12062867, 0.98555979, 0.48303426, 0.60306013,
                                          0.8263408 , 0.51948512};

    std::vector< double > answer = {0.55229547, 0.39800778, 0.58445349, 0.97563702, 0.56638939,
                                    0.92560448, 0.98390231, 0.60555346, 0.87605526, 0.88571157,
                                    0.38229773, 0.75537961};

    Eigen::Map< Eigen::Matrix< double, -1, -1 > > s(stressVector.data(), A.cols(), 1);
    std::vector< double > result(A.rows(), 0);
    Eigen::Map< Eigen::Matrix< double, -1, -1 > > r(result.data(), A.rows(), 1);
    r = A * s;

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_full_linear_momentum_matrix (test 1b) & False\n";
        return 1;
    }

    results << "test_full_linear_momentum_matrix & True\n";
    return 0;
}

int test_full_balance_equation_matrix(std::ofstream &results){
    /*!
     * Test the construction of the full balance equation matrix 
     * for the determination of the Cauchy and higher order stresses.
     * 
     * :param std::ofstream results: The output file.
     */

    overlap::vecOfvec com_shape_functions = {
        { +0.6964692, +0.2861393, +0.2268515, +0.5513148 },
        { +0.7194690, +0.4231065, +0.9807642, +0.6848297 },
    };

    std::vector< overlap::vecOfvec > com_shape_function_gradients = {
        {
            { +0.3427638, +0.3041208, +0.4170222},
            { +0.6813008, +0.8754568, +0.5104223},
            { +0.6693138, +0.5859366, +0.6249035},
            { +0.6746891, +0.8423424, +0.0831950}
        },
        {
            { +0.7636828, +0.2436664, +0.1942230},
            { +0.5724570, +0.0957125, +0.8853268},
            { +0.6272490, +0.7234164, +0.0161292},
            { +0.5944319, +0.5567852, +0.1589596}
        },
    };

    std::vector< double > volume = {0.86630916, 0.25045537};

    Eigen::MatrixXd A;
    overlap::full_balance_equation_matrix(com_shape_functions, com_shape_function_gradients, volume, A);

    if ((A.rows() != 3 * 4 + 9 * 4) || (A.cols() != (9 * 2 + 27 * 2))){
        results << "test_linear_momentum_cauchy_matrix (test 1a) & False\n";
        return 1;
    }

    std::vector< double > stressVector = {0.36178866, 0.09210494, 0.42583029, 0.43370117, 0.29371405,
                                          0.22826323, 0.4936851 , 0.43086276, 0.63097612, 0.31226122,
                                          0.50183668, 0.41482621, 0.62395295, 0.89338916, 0.42635131,
                                          0.31728548, 0.1156184 , 0.94416002, 0.69646919, 0.71946897,
                                          0.4809319 , 0.42310646, 0.22685145, 0.28613933, 0.68482974,
                                          0.9807642 , 0.55131477, 0.39211752, 0.0596779 , 0.17545176,
                                          0.39804426, 0.72904971, 0.34317802, 0.18249173, 0.73799541,
                                          0.43857224, 0.53155137, 0.72445532, 0.36178866, 0.61102351,
                                          0.63440096, 0.53182759, 0.32295891, 0.72244338, 0.84943179,
                                          0.22826323, 0.43370117, 0.31226122, 0.43086276, 0.63097612,
                                          0.29371405, 0.42583029, 0.4936851 , 0.09210494, 0.42635131,
                                          0.62395295, 0.86630916, 0.1156184 , 0.94416002, 0.89338916,
                                          0.41482621, 0.31728548, 0.50183668, 0.25045537, 0.61289453,
                                          0.54506801, 0.12062867, 0.98555979, 0.48303426, 0.60306013,
                                          0.8263408 , 0.51948512};

    std::vector< double > answer = {0.55229547,  0.39800778,  0.58445349,  0.97563702,  0.56638939,
                                    0.92560448,  0.98390231,  0.60555346,  0.87605526,  0.88571157,
                                    0.38229773,  0.75537961,  0.30945725,  0.49593053,  0.12716741,
                                    0.19154371,  0.43407781, -0.04912658,  0.1300972 ,  0.56244649,
                                    0.44509074,  0.91920975,  0.92727425,  0.61377877,  0.75708681,
                                    1.17991221,  0.5784928 ,  0.71649904,  1.55216144,  1.07228067,
                                    0.85695191,  0.88194373,  0.58641329,  0.69232763,  1.00613984,
                                    0.48205847,  0.57055081,  1.19559906,  0.96004416,  0.60858558,
                                    0.56219888,  0.34967185,  0.37666636,  0.74954836,  0.18024239,
                                    0.38781578,  1.02098032,  0.62572454};

    Eigen::Map< Eigen::Matrix< double, -1, -1 > > s(stressVector.data(), A.cols(), 1);
    std::vector< double > result(A.rows(), 0);
    Eigen::Map< Eigen::Matrix< double, -1, -1 > > r(result.data(), A.rows(), 1);
    r = A * s;

    if (!vectorTools::fuzzyEquals(result, answer)){
        results << "test_full_balance_equation_matrix (test 1b) & False\n";
        return 1;
    }

    results << "test_full_balance_equation_matrix & True\n";
    return 0;

}

int test_compute_first_moment_symm_microstress_contribution(std::ofstream &results){
    /*!
     * Test the calculation of the contribution of the symmetric micro-stress to the 
     * balance of first moment of momentum.
     * 
     * :param std::ofstream &results: The output file.
     */

    overlap::vecOfvec com_shape_functions = {
        { +0.6964692, +0.2861393, +0.2268515, +0.5513148 },
        { +0.7194690, +0.4231065, +0.9807642, +0.6848297 },
    };

    std::vector< double > volume = {0.86630916, 0.25045537};

    overlap::vecOfvec symmetricMicrostress = {
        { +0.4809319, +0.4385722, +0.1824917, +0.0596779, +0.3431780, +0.3921175, +0.7379954, +0.3980443, +0.7290497 },
        { +0.1754518, +0.8494318, +0.3229589, +0.7244553, +0.5318276, +0.5315514, +0.7224434, +0.6110235, +0.6344010 },
    };

    std::vector< double > b;
    overlap::compute_first_moment_symm_microstress_contribution(com_shape_functions, volume, symmetricMicrostress, b);

    std::vector< double > answer = {-0.32178944, -0.41767916, -0.16830332, -0.57545575, -0.35026634,
           -0.5541935 , -0.16655024, -0.30289168, -0.33236993, -0.13780836,
           -0.19872921, -0.07946071, -0.25949489, -0.16341897, -0.24794759,
           -0.09156327, -0.14142611, -0.15352822, -0.13761197, -0.29484218,
           -0.11519478, -0.32249273, -0.22831543, -0.29910816, -0.18968162,
           -0.19807942, -0.20762934, -0.25979078, -0.35516   , -0.14255338,
           -0.47638624, -0.29491185, -0.45701272, -0.15276076, -0.25512361,
           -0.27845018};

    if (!vectorTools::fuzzyEquals(answer, b)){
        results << "test_compute_first_moment_symm_microstress_contribution (test 1) & False\n";
        return 1;
    }

    results << "test_compute_first_moment_symm_microstress_contribution & True\n";
    return 0;
}

int test_construct_linear_momentum_rhs(std::ofstream &results){
    /*!
     * Test the construction of the right-hand side of the balance of linear momentum 
     * for the calculation of the Cauchy and higher order stresses.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< double > surface_external_force = {1, 2, 3, 4};
    std::vector< double > body_external_force    = {4, 5, 6, 7};
    std::vector< double > kinetic_force          = {10, 11, 12, 13};

    std::vector< double > linear_momentum_rhs;
    overlap::construct_linear_momentum_rhs(surface_external_force, body_external_force, kinetic_force, linear_momentum_rhs);

    if (!vectorTools::fuzzyEquals(linear_momentum_rhs, surface_external_force + body_external_force - kinetic_force)){
        results << "test_construct_linear_momentum_rhs (test 1) & False\n";
        return 1;
    }

    results << "test_construct_linear_momentum_rhs & True\n";
    return 0;
}

int test_construct_first_moment_rhs(std::ofstream &results){
    /*!
     * Test the construction of the right-hand side of the balance of the first moment of 
     * momentum for the calculation of the Cauchy and higher order stresses.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< double > surface_external_couple = {1, 2, 3, 4};
    std::vector< double > body_external_couple    = {4, 5, 6, 7};
    std::vector< double > kinetic_couple          = {10, 11, 12, 13};
    std::vector< double > symmetric_contribution  = {-1, -2, -3, -4};

    std::vector< double > first_moment_rhs;
    overlap::construct_first_moment_rhs(surface_external_couple, body_external_couple, kinetic_couple, 
                                        symmetric_contribution, first_moment_rhs);

    if (!vectorTools::fuzzyEquals(first_moment_rhs, surface_external_couple + body_external_couple - kinetic_couple + 
                                                    symmetric_contribution)){
        results << "test_construct_first_moment_rhs (test 1) & False\n";
        return 1;
    }

    results << "test_construct_first_moment_rhs & True\n";
    return 0;
}

int test_construct_balance_equation_rhs(std::ofstream &results){
    /*!
     * Test the construction of the right-hand side of the balance equations for 
     * the calculation of the Cauchy and higher order stresses.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< double > surface_external_force = {1, 2, 3, 4};
    std::vector< double > body_external_force    = {4, 5, 6, 7};
    std::vector< double > kinetic_force          = {10, 11, 12, 13};

    std::vector< double > linear_momentum_rhs = surface_external_force + body_external_force - kinetic_force;
    
    std::vector< double > surface_external_couple = {7, 6, 5, 4};
    std::vector< double > body_external_couple    = {18, 22, 24, 73};
    std::vector< double > kinetic_couple          = {12, 13, 14, 15};
    std::vector< double > symmetric_contribution  = {-8, -9, -10, -11};

    std::vector< double > first_moment_rhs = surface_external_couple + body_external_couple
                                           - kinetic_couple + symmetric_contribution;

    std::vector< double > balance_equation_rhs;
    overlap::construct_balance_equation_rhs(surface_external_force, body_external_force, kinetic_force,
                                            surface_external_couple, body_external_couple, kinetic_couple,
                                            symmetric_contribution, balance_equation_rhs);

    std::vector< double > answer(0);
    answer.insert(answer.end(), linear_momentum_rhs.begin(), linear_momentum_rhs.end());
    answer.insert(answer.end(), first_moment_rhs.begin(), first_moment_rhs.end());

    if (!vectorTools::fuzzyEquals(answer, balance_equation_rhs)){
        results << "test_construct_balance_equation_rhs (test 1) & False\n";
        return 1;
    }
    
    results << "test_construct_balance_equation_rhs & True\n";
    return 1;
}

int test_MADOutlierDetection(std::ofstream &results){
    /*!
     * Test the computation of outliers using the maximum absolution deviation 
     * detection metric.
     * 
     * :param std::ofstream &results: The output file.
     */

    std::vector< double > x = {0.70154526, 0.00265005, 0.29766985, 0.0570927 , 0.12136678};
    std::vector< unsigned int > outliers;

    overlap::MADOutlierDetection(x, outliers, 5);

    if (outliers.size() > 0){
        results << "test_MADOutlierDetection (test 1) & False\n";
        return 1;
    }

    overlap::MADOutlierDetection(x, outliers, 4);

    if (!vectorTools::fuzzyEquals(outliers, {0})){
        results << "test_MADOutlierDetection (test 1) & False\n";
        return 1;
    }

    results << "test_MADOutlierDetection & True\n";
    return 0;
}

int main(){
    /*!
    The main loop which runs the tests defined in the 
    accompanying functions. Each function should output
    the function name followed by & followed by True or False 
    if the test passes or fails respectively.
    */

    //Open the results file
    std::ofstream results;
    results.open("results.tex");

    overlap::ParsedData data = overlap::read_data_from_file("overlap.txt");

    //Tests for the interface to the hull building routines
    test_map_vector_to_quickhull(results);
    test_mapVectorsToQuickhull(results);
    test_map_quickhull_to_vector(results);
    test_map_quickhull_to_vectors(results);

    //Test for the computations of the bounds
    test_extract_mesh_info(results);
    test_compute_element_bounds(results);
    test_compute_node_bounds(results);
    test_compute_dns_bounds(results);
    test_construct_gauss_domains(results);

    //Tests for the interface to Voro++
    test_construct_container(results);

    //Tests for the computation of the weights
    test_compute_weights(results);

    //Tests for the integrators
    test_perform_volume_integration(results);
    test_perform_surface_integration(results);
    test_perform_position_weighted_volume_integration(results);
    test_compute_surface_information(results);
    test_perform_symmetric_tensor_surface_traction_integration(results);
    test_perform_symmetric_tensor_surface_couple_traction_integration(results);

    //Test on the nodal quantity computations
    test_construct_linear_momentum_surface_external_force(results);
    test_construct_first_moment_surface_external_couple(results);
    test_construct_first_moment_symm_cauchy_couple(results);
    test_first_moment_cauchy_matrix(results);
    test_firstMomentHostressMatrix(results);
    test_full_first_moment_matrix(results);
    test_linear_momentum_cauchy_matrix(results);
    test_full_linear_momentum_matrix(results);
    test_full_balance_equation_matrix(results);
    test_compute_first_moment_symm_microstress_contribution(results);
    test_construct_linear_momentum_rhs(results);
    test_construct_first_moment_rhs(results);
    test_construct_balance_equation_rhs(results);

    //Test misc. functions
    test_dot(results);
    test_cross(results);
    test_fuzzy_equals(results);
    test_compare_vector_directions(results);
    test_normal_from_vertices(results);
    test_apply_nansons_relation(results);
    test_split(results);
    test_point_on_surface(results);
    test_solve_constrained_least_squares(results);
    test_id_unique_vectors(results);
    test_MADOutlierDetection(results);

    //Close the results file
    results.close();
}
